{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"kiara modules (default) \u00b6 A set of commonly used/useful default modules (and pipelines) for Kiara . Documentation: https://dharpa.org/kiara_modules.default Code: https://github.com/DHARPA-Project/kiara_modules.default Description \u00b6 Kiara is the data orchestration engine driving the DHARPA project application (yet to be named). This repository contains a set of officially supported processing modules and pipelines. Development \u00b6 Requirements \u00b6 Python (version >=3.6 -- some make targets only work for Python >=3.7 though) pip, virtualenv git make direnv (optional) Prepare development environment \u00b6 If you only want to work on the modules, and not the core Kiara codebase, follow the instructions below. Otherwise, please check the notes on how to setup a Kiara development environment under (TODO). git clone https://github.com/DHARPA-Project/kiara_modules.default.git cd kiara python3 -m venv .venv source .venv/bin/activate make init make targets \u00b6 init : init development project (install project & dev dependencies into virtualenv, as well as pre-commit git hook) update-dependencies : update development dependencies (mainly the core kiara package from git) flake : run flake8 tests mypy : run mypy tests test : run unit tests docs : create static documentation pages (under build/site ) serve-docs : serve documentation pages (incl. auto-reload) for getting direct feedback when working on documentation clean : clean build directories For details (and other, minor targets), check the Makefile . Running tests \u00b6 > make test # or > make coverage Copyright & license \u00b6 This project is MPL v2.0 licensed, for the license text please check the LICENSE file in this repository. Copyright (c) 2021 DHARPA project","title":"Home"},{"location":"#kiara-modules-default","text":"A set of commonly used/useful default modules (and pipelines) for Kiara . Documentation: https://dharpa.org/kiara_modules.default Code: https://github.com/DHARPA-Project/kiara_modules.default","title":"kiara modules (default)"},{"location":"#description","text":"Kiara is the data orchestration engine driving the DHARPA project application (yet to be named). This repository contains a set of officially supported processing modules and pipelines.","title":"Description"},{"location":"#development","text":"","title":"Development"},{"location":"#requirements","text":"Python (version >=3.6 -- some make targets only work for Python >=3.7 though) pip, virtualenv git make direnv (optional)","title":"Requirements"},{"location":"#prepare-development-environment","text":"If you only want to work on the modules, and not the core Kiara codebase, follow the instructions below. Otherwise, please check the notes on how to setup a Kiara development environment under (TODO). git clone https://github.com/DHARPA-Project/kiara_modules.default.git cd kiara python3 -m venv .venv source .venv/bin/activate make init","title":"Prepare development environment"},{"location":"#make-targets","text":"init : init development project (install project & dev dependencies into virtualenv, as well as pre-commit git hook) update-dependencies : update development dependencies (mainly the core kiara package from git) flake : run flake8 tests mypy : run mypy tests test : run unit tests docs : create static documentation pages (under build/site ) serve-docs : serve documentation pages (incl. auto-reload) for getting direct feedback when working on documentation clean : clean build directories For details (and other, minor targets), check the Makefile .","title":"make targets"},{"location":"#running-tests","text":"> make test # or > make coverage","title":"Running tests"},{"location":"#copyright-license","text":"This project is MPL v2.0 licensed, for the license text please check the LICENSE file in this repository. Copyright (c) 2021 DHARPA project","title":"Copyright &amp; license"},{"location":"modules_list/","text":"Available module types \u00b6 This page contains a list of all available Kiara module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type. add_nodes_to_network_graph \u00b6 \u256d\u2500 Module: add_nodes_to_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.AddNodesToNetwork\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Add nodes to an existing graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.add_nodes_to_network_graph \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 nodes_table_value = inputs.get_value_obj(\"node_attri\u2026 \u2502 \u2502 \u2502 \u2502 if nodes_table_value.is_none: \u2502 \u2502 # we return the graph as is \u2502 \u2502 # we are using the 'get_value_obj' method, becau\u2026 \u2502 \u2502 # actual data at all \u2502 \u2502 outputs.set_value(\"graph\", inputs.get_value_obj(\u2026 \u2502 \u2502 return \u2502 \u2502 \u2502 \u2502 input_graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 graph: Graph = copy.deepcopy(input_graph) \u2502 \u2502 \u2502 \u2502 nodes_table_obj: pyarrow.Table = nodes_table_value.g\u2026 \u2502 \u2502 nodes_table_index = inputs.get_value_data(\"index_col\u2026 \u2502 \u2502 \u2502 \u2502 attr_dict = ( \u2502 \u2502 nodes_table_obj.to_pandas() \u2502 \u2502 .set_index(nodes_table_index) \u2502 \u2502 .to_dict(\"index\") \u2502 \u2502 .items() \u2502 \u2502 ) \u2502 \u2502 graph.add_nodes_from(attr_dict) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f and \u00b6 \u256d\u2500 Module: and \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.AndModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if both inputs are 'True'. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.and \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.delay) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value( \u2502 \u2502 \"y\", inputs.get_value_data(\"a\") and inputs.get_v\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f augment_network_graph \u00b6 \u256d\u2500 Module: augment_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.AugmentNetworkGra\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Augment an existing graph with node attributes. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.augment_network_graph \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 nodes_table_value = inputs.get_value_obj(\"node_attri\u2026 \u2502 \u2502 \u2502 \u2502 if nodes_table_value.is_none or not nodes_table_valu\u2026 \u2502 \u2502 # we return the graph as is \u2502 \u2502 # we are using the 'get_value_obj' method, becau\u2026 \u2502 \u2502 # actual data at all \u2502 \u2502 outputs.set_value(\"graph\", inputs.get_value_obj(\u2026 \u2502 \u2502 return \u2502 \u2502 \u2502 \u2502 input_graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 graph: Graph = copy.deepcopy(input_graph) \u2502 \u2502 \u2502 \u2502 nodes_table_obj: pyarrow.Table = nodes_table_value.g\u2026 \u2502 \u2502 nodes_table_index = inputs.get_value_data(\"index_col\u2026 \u2502 \u2502 if nodes_table_index not in nodes_table_obj.column_n\u2026 \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Node attribute table does not have a colum\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 attr_dict = ( \u2502 \u2502 nodes_table_obj.to_pandas() \u2502 \u2502 .set_index(nodes_table_index) \u2502 \u2502 .to_dict(\"index\") \u2502 \u2502 .items() \u2502 \u2502 ) \u2502 \u2502 graph.add_nodes_from(attr_dict) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f create_graph_from_edges_table \u00b6 \u256d\u2500 Module: create_graph_from_edges_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.CreateGraphFromEd\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Create a directed network graph object from tabular data. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_graph_from_edges_table \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.CreateGraphConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 graph_type string The type of the graph. If not \u2502 \u2502 specified, a 'graph_type' input \u2502 \u2502 field will be added which will \u2502 \u2502 default to 'directed'. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"graph_type\") is not None: \u2502 \u2502 _graph_type = self.get_config_value(\"graph_type\") \u2502 \u2502 else: \u2502 \u2502 _graph_type = inputs.get_value_data(\"graph_type\") \u2502 \u2502 \u2502 \u2502 graph_type = GraphTypesEnum[_graph_type] \u2502 \u2502 \u2502 \u2502 edges_table_value = inputs.get_value_obj(\"edges_tabl\u2026 \u2502 \u2502 edges_table_obj: pyarrow.Table = edges_table_value.g\u2026 \u2502 \u2502 \u2502 \u2502 source_column = inputs.get_value_data(\"source_column\u2026 \u2502 \u2502 target_column = inputs.get_value_data(\"target_column\u2026 \u2502 \u2502 weight_column = inputs.get_value_data(\"weight_column\u2026 \u2502 \u2502 \u2502 \u2502 errors = [] \u2502 \u2502 if source_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(source_column) \u2502 \u2502 if target_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(target_column) \u2502 \u2502 if weight_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(weight_column) \u2502 \u2502 \u2502 \u2502 if errors: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't create network graph, source table m\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 min_table = edges_table_obj.select( \u2502 \u2502 (source_column, target_column, weight_column) \u2502 \u2502 ) \u2502 \u2502 pandas_table = min_table.to_pandas() \u2502 \u2502 \u2502 \u2502 if graph_type != GraphTypesEnum.directed: \u2502 \u2502 raise NotImplementedError(\"Only 'directed' graph\u2026 \u2502 \u2502 graph_cls = nx.DiGraph \u2502 \u2502 \u2502 \u2502 graph: nx.DiGraph = nx.from_pandas_edgelist( \u2502 \u2502 pandas_table, \u2502 \u2502 source_column, \u2502 \u2502 target_column, \u2502 \u2502 edge_attr=True, \u2502 \u2502 create_using=graph_cls, \u2502 \u2502 ) \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f create_table_from_file \u00b6 \u256d\u2500 Module: create_table_from_file \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.CreateTableFromFileMo\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Import table-like data from an item in the data registry. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_table_from_file \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.CreateTableModuleConf\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 allow_column_filter boolean Whether to add an \u2502 \u2502 input option to \u2502 \u2502 filter columns. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_file: FileModel = inputs.get_value_data(\"file\") \u2502 \u2502 \u2502 \u2502 imported_data = pa.csv.read_csv(input_file.path) \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"allow_column_filter\"): \u2502 \u2502 if self.get_config_value(\"columns\"): \u2502 \u2502 imported_data = imported_data.select( \u2502 \u2502 self.get_config_value(\"only_columns\") \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", imported_data) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f create_table_from_text_files \u00b6 \u256d\u2500 Module: create_table_from_text_files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.CreateTableFromTextFi\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_table_from_text_files \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.CreateTableFromTextFi\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 columns array A list of columns to add to the \u2502 \u2502 table. Available properties: id, \u2502 \u2502 rel_path, orig_filename, \u2502 \u2502 orig_path, import_time, \u2502 \u2502 mime_type, size, content, path, \u2502 \u2502 file_name \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 bundle: FileBundleModel = inputs.get_value_data(\"fil\u2026 \u2502 \u2502 \u2502 \u2502 columns = self.get_config_value(\"columns\") \u2502 \u2502 if not columns: \u2502 \u2502 columns = DEFAULT_COLUMNS \u2502 \u2502 \u2502 \u2502 if \"content\" in columns: \u2502 \u2502 file_dict = bundle.read_text_file_contents() \u2502 \u2502 else: \u2502 \u2502 file_dict = {} \u2502 \u2502 for rel_path in bundle.included_files.keys(): \u2502 \u2502 file_dict[rel_path] = None # type: ignore \u2502 \u2502 \u2502 \u2502 tabular: typing.Dict[str, typing.List[typing.Any]] =\u2026 \u2502 \u2502 for column in columns: \u2502 \u2502 for index, rel_path in enumerate(sorted(file_dic\u2026 \u2502 \u2502 \u2502 \u2502 if column == \"content\": \u2502 \u2502 value: typing.Any = file_dict[rel_path] \u2502 \u2502 elif column == \"id\": \u2502 \u2502 value = index \u2502 \u2502 elif column == \"rel_path\": \u2502 \u2502 value = rel_path \u2502 \u2502 else: \u2502 \u2502 file_model = bundle.included_files[rel_p\u2026 \u2502 \u2502 value = getattr(file_model, column) \u2502 \u2502 \u2502 \u2502 tabular.setdefault(column, []).append(value) \u2502 \u2502 \u2502 \u2502 table = pa.Table.from_pydict(tabular) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", table) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f date_range_check \u00b6 \u256d\u2500 Module: date_range_check \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dates.DateRangeCheckModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether a date falls within a specified date range. \u2502 \u2502 \u2502 \u2502 At least one of the inputs 'earliest' or 'latest' must be \u2502 \u2502 set, it's allowed to set both, though. \u2502 \u2502 \u2502 \u2502 Return ``True`` if that's the case, otherwise ``False``. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.date_range_check \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 d = inputs.get_value_data(\"date\") \u2502 \u2502 earliest: typing.Optional[datetime.datetime] = input\u2026 \u2502 \u2502 latest: typing.Optional[datetime.datetime] = inputs.\u2026 \u2502 \u2502 \u2502 \u2502 if hasattr(d, \"as_py\"): \u2502 \u2502 d = d.as_py() \u2502 \u2502 \u2502 \u2502 if not earliest and not latest: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 \"Can't process date range check: need at lea\u2026 \u2502 \u2502 ) \u2502 \u2502 elif earliest and latest: \u2502 \u2502 matches = earliest <= d <= latest \u2502 \u2502 elif earliest: \u2502 \u2502 matches = earliest <= d \u2502 \u2502 else: \u2502 \u2502 matches = d <= latest \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"within_range\", matches) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f dummy \u00b6 \u256d\u2500 Module: dummy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dev.DummyModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Module that simulates processing, but uses hard-coded \u2502 \u2502 outputs as a result. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.dummy \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.dev.DummyProcessingModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 doc string -- n/a -- \u2502 \u2502 input_schema object The input schema for this \u2502 \u2502 module. \u2502 \u2502 output_schema object The output schema for this \u2502 \u2502 module. \u2502 \u2502 outputs object The (dummy) output for this \u2502 \u2502 module. \u2502 \u2502 delay number The delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 (dummy) outputs are \u2502 \u2502 returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \"\"\"Returns the hardcoded output values that are set \u2026 \u2502 \u2502 \u2502 \u2502 Optionally, this module can simulate processing by w\u2026 \u2502 \u2502 \"\"\" \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 \u2502 \u2502 output_values: typing.Mapping = self.config.get(\"out\u2026 \u2502 \u2502 \u2502 \u2502 value_dict = {} \u2502 \u2502 for output_name in self.output_names: \u2502 \u2502 if output_name not in output_values.keys(): \u2502 \u2502 raise NotImplementedError() \u2502 \u2502 # v = self.output_schemas[output_name].type_\u2026 \u2502 \u2502 # value_dict[output_name] = v \u2502 \u2502 else: \u2502 \u2502 value_dict[output_name] = output_values[outp\u2026 \u2502 \u2502 outputs.set_values(**value_dict) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f extract_date \u00b6 \u256d\u2500 Module: extract_date \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dates.ExtractDateModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.extract_date \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 \u2502 \u2502 date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", te\u2026 \u2502 \u2502 assert date_match \u2502 \u2502 \u2502 \u2502 d_obj = parser.parse(date_match[0]) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"date\", d_obj) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f filter_table \u00b6 \u256d\u2500 Module: filter_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.FilterTableModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.filter_table \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.TableFilterModuleConf\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_table: pa.Table = inputs.get_value_data(\"table\u2026 \u2502 \u2502 filter_array: pa.Array = inputs.get_value_data(\"mask\u2026 \u2502 \u2502 \u2502 \u2502 filtered = input_table.filter(filter_array) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", filtered) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f find_shortest_path \u00b6 \u256d\u2500 Module: find_shortest_path \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.FindShortestPathM\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Find the shortest path between two nodes in a graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.find_shortest_path \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.FindShortestPathM\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 mode string Whether to calculate one \u2502 \u2502 shortest path for only one pair \u2502 \u2502 ('single-pair'), or use two node \u2502 \u2502 lists as input and select one of \u2502 \u2502 the following strategies: \u2502 \u2502 shortest path for each pair \u2502 \u2502 ('one-to-one'), the shortest \u2502 \u2502 path to all targets \u2502 \u2502 ('one-to-many'), or a matrix of \u2502 \u2502 all possible combinations \u2502 \u2502 ('many-to-many'). \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 mode = self.get_config_value(\"mode\") \u2502 \u2502 if mode != \"single-pair\": \u2502 \u2502 raise NotImplementedError() \u2502 \u2502 \u2502 \u2502 graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 source: typing.Any = inputs.get_value_data(\"source_n\u2026 \u2502 \u2502 target: typing.Any = inputs.get_value_data(\"target_n\u2026 \u2502 \u2502 \u2502 \u2502 if source not in graph.nodes: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't process shortest path, source '{sour\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 if target not in graph.nodes: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't process shortest path, target '{targ\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 shortest_path = nx.shortest_path(graph, source=sourc\u2026 \u2502 \u2502 outputs.set_value(\"path\", shortest_path) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f graph_properties \u00b6 \u256d\u2500 Module: graph_properties \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.ExtractGraphPrope\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Extract inherent properties of a network graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.graph_properties \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.ExtractGraphPrope\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 find_largest_compon\u2026 boolean Find the largest \u2502 \u2502 component of a \u2502 \u2502 graph. \u2502 \u2502 number_of_nodes boolean Count the number of \u2502 \u2502 nodes. \u2502 \u2502 number_of_edges boolean Count the number of \u2502 \u2502 edges \u2502 \u2502 density boolean Calculate the graph \u2502 \u2502 density. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"find_largest_component\"): \u2502 \u2502 lc_graph = copy.deepcopy(graph) \u2502 \u2502 # largest_component = max(nx.strongly_connected_\u2026 \u2502 \u2502 lc_graph.remove_nodes_from( \u2502 \u2502 list(nx.isolates(lc_graph)) \u2502 \u2502 ) # remove unconnected nodes from graph \u2502 \u2502 lc_density = nx.density(lc_graph) \u2502 \u2502 outputs.set_values( \u2502 \u2502 largest_component=lc_graph, density_largest_\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"number_of_nodes\"): \u2502 \u2502 outputs.set_values(number_of_nodes=len(graph.nod\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"number_of_edges\"): \u2502 \u2502 outputs.set_values(number_of_edges=len(graph.edg\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"density\"): \u2502 \u2502 density = nx.density(graph) \u2502 \u2502 outputs.set_values(density=density) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f import_local_file \u00b6 \u256d\u2500 Module: import_local_file \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.data_onboarding.ImportLocalFileMod\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Read a file into the data registry. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.import_local_file \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.data_onboarding.ImportLocalPathCon\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 source_is_immutable boolean Whether the data that \u2502 \u2502 lives in source path \u2502 \u2502 can be relied upon to \u2502 \u2502 not change, and \u2502 \u2502 always be available \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 path = inputs.get_value_data(\"path\") \u2502 \u2502 file_model = FileModel.import_file(path) \u2502 \u2502 outputs.set_value(\"file\", file_model) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f import_local_folder \u00b6 \u256d\u2500 Module: import_local_folder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.data_onboarding.ImportLocalFolderM\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.import_local_folder \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.data_onboarding.ImportLocalPathCon\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 source_is_immutable boolean Whether the data that \u2502 \u2502 lives in source path \u2502 \u2502 can be relied upon to \u2502 \u2502 not change, and \u2502 \u2502 always be available \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 path = inputs.get_value_data(\"path\") \u2502 \u2502 \u2502 \u2502 included_files = inputs.get_value_data(\"included_fil\u2026 \u2502 \u2502 excluded_dirs = inputs.get_value_data(\"excluded_dirs\u2026 \u2502 \u2502 \u2502 \u2502 import_config = FolderImportConfig( \u2502 \u2502 include_files=included_files, exclude_dirs=exclu\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 bundle = FileBundleModel.import_folder(source=path, \u2026 \u2502 \u2502 \u2502 \u2502 outputs.set_values(file_bundle=bundle) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f included_in_list_check \u00b6 \u256d\u2500 Module: included_in_list_check \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.lists.IncludedInListCheckModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether an element is in a list. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.included_in_list_check \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 item_list = inputs.get_value_data(\"list\") \u2502 \u2502 item = inputs.get_value_data(\"item\") \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"is_included\", item in item_list) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f map \u00b6 \u256d\u2500 Module: map \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.array_data.MapModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Map a list of values into another list of values. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.map \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.array_data.MapModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 module_type string The name of the kiara module \u2502 \u2502 to use to filter the input \u2502 \u2502 data. \u2502 \u2502 module_config object The config for the kiara \u2502 \u2502 filter module. \u2502 \u2502 input_name string The name of the input name \u2502 \u2502 of the module which will \u2502 \u2502 receive the items from our \u2502 \u2502 input array. Can be omitted \u2502 \u2502 if the configured module \u2502 \u2502 only has a single input. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_array: pa.Array = inputs.get_value_data(\"array\u2026 \u2502 \u2502 \u2502 \u2502 module_name = self.get_config_value(\"module_type\") \u2502 \u2502 module_config = self.get_config_value(\"module_config\u2026 \u2502 \u2502 module_obj: KiaraModule = self._kiara.create_module( \u2502 \u2502 \"_map_module\", module_name, module_config=module\u2026 \u2502 \u2502 ) \u2502 \u2502 # TODO: validate that the selected module is appropr\u2026 \u2502 \u2502 assert len(list(module_obj.output_names)) == 1 \u2502 \u2502 \u2502 \u2502 module_output_name = list(module_obj.output_names)[0] \u2502 \u2502 \u2502 \u2502 init_data: typing.Dict[str, typing.Any] = {} \u2502 \u2502 for input_name in self.input_schemas.keys(): \u2502 \u2502 if input_name in [\"array\", self.module_input_nam\u2026 \u2502 \u2502 continue \u2502 \u2502 \u2502 \u2502 init_data[input_name] = inputs.get_value_obj(inp\u2026 \u2502 \u2502 \u2502 \u2502 multi_threaded = False \u2502 \u2502 if multi_threaded: \u2502 \u2502 \u2502 \u2502 def run_module(item): \u2502 \u2502 _d = copy.copy(init_data) \u2502 \u2502 assert self._module_input_name is not None \u2502 \u2502 _d[self._module_input_name] = item \u2502 \u2502 r = module_obj.run(**_d) \u2502 \u2502 return r.get_all_value_data() \u2502 \u2502 \u2502 \u2502 executor = ThreadPoolExecutor() \u2502 \u2502 results: typing.Any = executor.map(run_module, i\u2026 \u2502 \u2502 executor.shutdown(wait=True) \u2502 \u2502 \u2502 \u2502 else: \u2502 \u2502 results = [] \u2502 \u2502 for item in input_array: \u2502 \u2502 _d = copy.copy(init_data) \u2502 \u2502 assert self._module_input_name is not None \u2502 \u2502 _d[self._module_input_name] = item \u2502 \u2502 r = module_obj.run(**_d) \u2502 \u2502 results.append(r.get_all_value_data()) \u2502 \u2502 \u2502 \u2502 result_list = [] \u2502 \u2502 result_types = set() \u2502 \u2502 for r in results: \u2502 \u2502 r_item = r[module_output_name] # type: ignore \u2502 \u2502 result_list.append(r_item) \u2502 \u2502 result_types.add(type(r_item)) \u2502 \u2502 \u2502 \u2502 assert len(result_types) == 1 \u2502 \u2502 outputs.set_value(\"array\", pa.array(result_list)) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f match_regex \u00b6 \u256d\u2500 Module: match_regex \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.RegexModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether the input string matches a provided regular \u2502 \u2502 expression. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.match_regex \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.strings.RegexModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 regex string The regex to apply. \u2502 \u2502 only_first_match boolean Whether to only return \u2502 \u2502 the first match, or all \u2502 \u2502 matches. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 regex = self.get_config_value(\"regex\") \u2502 \u2502 matches = re.findall(regex, text) \u2502 \u2502 \u2502 \u2502 if not matches: \u2502 \u2502 raise KiaraProcessingException(f\"No match for re\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"only_first_match\"): \u2502 \u2502 result = matches[0] \u2502 \u2502 else: \u2502 \u2502 result = matches \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"text\", result) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f merge_table \u00b6 \u256d\u2500 Module: merge_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.MergeTableModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.merge_table \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 sources = inputs.get_value_data(\"sources\") \u2502 \u2502 \u2502 \u2502 len_dict = {} \u2502 \u2502 arrays = [] \u2502 \u2502 column_names = [] \u2502 \u2502 for source_key, table_or_column in sources.items(): \u2502 \u2502 \u2502 \u2502 if isinstance(table_or_column, pa.Table): \u2502 \u2502 rows = table_or_column.num_rows \u2502 \u2502 for name in table_or_column.schema.names: \u2502 \u2502 column = table_or_column.column(name) \u2502 \u2502 arrays.append(column) \u2502 \u2502 column_names.append(name) \u2502 \u2502 \u2502 \u2502 elif isinstance(table_or_column, pa.Array): \u2502 \u2502 rows = len(table_or_column) \u2502 \u2502 arrays.append(table_or_column) \u2502 \u2502 column_names.append(source_key) \u2502 \u2502 else: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't merge table: invalid type '{type\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 len_dict[source_key] = rows \u2502 \u2502 \u2502 \u2502 all_rows = None \u2502 \u2502 for source_key, rows in len_dict.items(): \u2502 \u2502 if all_rows is None: \u2502 \u2502 all_rows = rows \u2502 \u2502 else: \u2502 \u2502 if all_rows != rows: \u2502 \u2502 all_rows = None \u2502 \u2502 break \u2502 \u2502 \u2502 \u2502 if all_rows is None: \u2502 \u2502 len_str = \"\" \u2502 \u2502 for name, rows in len_dict.items(): \u2502 \u2502 len_str = f\" {name} ({rows})\" \u2502 \u2502 \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't merge table, sources have different \u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 table = pa.Table.from_arrays(arrays=arrays, names=co\u2026 \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", table) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f not \u00b6 \u256d\u2500 Module: not \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.NotModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Negates the input. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.not \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \"\"\"Negates the input boolean.\"\"\" \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"y\", not inputs.get_value_data(\"a\"\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f or \u00b6 \u256d\u2500 Module: or \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.OrModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if one of the inputs is 'True'. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.or \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 outputs.set_value(\"y\", inputs.get_value_data(\"a\") or\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f prepare_nodes_table_lena \u00b6 \u256d\u2500 Module: prepare_nodes_table_lena \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.scratchpad.PrepareNodesTableLenaMo\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Prepare tabular data so it can be used as a 'nodes_table' \u2502 \u2502 input in the a directed graph module. \u2502 \u2502 \u2502 \u2502 This is a very specific module, only accepting a very \u2502 \u2502 specific data format and as such only suitable as a \u2502 \u2502 proof-of-concept. \u2502 \u2502 Later on, this will be replaced by a more generic module \u2502 \u2502 (or pipeline). \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.prepare_nodes_table_lena \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 t: pyarrow.Table = inputs.get_value_data(\"table\") \u2502 \u2502 df = t.to_pandas() \u2502 \u2502 \u2502 \u2502 df1 = df.iloc[:, 0:11] \u2502 \u2502 df1.columns = [ \u2502 \u2502 \"Id\", \u2502 \u2502 \"LabelOrig\", \u2502 \u2502 \"LabelTrans\", \u2502 \u2502 \"Year\", \u2502 \u2502 \"Type\", \u2502 \u2502 \"Language\", \u2502 \u2502 \"City\", \u2502 \u2502 \"CountryOld\", \u2502 \u2502 \"CountryNew\", \u2502 \u2502 \"Latitude\", \u2502 \u2502 \"Longitude\", \u2502 \u2502 ] \u2502 \u2502 df2 = df.iloc[ \u2502 \u2502 :, 11: \u2502 \u2502 ] # This slices the dataframe in half creating a df\u2026 \u2502 \u2502 df2.columns = [ \u2502 \u2502 \"Id\", \u2502 \u2502 \"Year\", \u2502 \u2502 \"LabelOrig\", \u2502 \u2502 \"LabelTrans\", \u2502 \u2502 \"Type\", \u2502 \u2502 \"Language\", \u2502 \u2502 \"City\", \u2502 \u2502 \"CountryOld\", \u2502 \u2502 \"CountryNew\", \u2502 \u2502 \"Latitude\", \u2502 \u2502 \"Longitude\", \u2502 \u2502 ] \u2502 \u2502 extr_nodes = df1.append(df2) \u2502 \u2502 extr_nodes_unique = extr_nodes.drop_duplicates(subse\u2026 \u2502 \u2502 \u2502 \u2502 result = pyarrow.Table.from_pandas(extr_nodes_unique) \u2502 \u2502 outputs.set_values(table=result, index_column_name=\"\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f pretty_print \u00b6 \u256d\u2500 Module: pretty_print \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.PrettyPrintModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.pretty_print \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 value_type = inputs.get_value_obj(\"item\").type_name \u2502 \u2502 input_value: Value = inputs.get_value_data(\"item\") \u2502 \u2502 \u2502 \u2502 max_lines = inputs.get_value_data(\"max_lines\") \u2502 \u2502 \u2502 \u2502 if value_type == \"table\": \u2502 \u2502 \u2502 \u2502 half_lines: typing.Optional[int] = None \u2502 \u2502 if max_lines: \u2502 \u2502 half_lines = int(max_lines / 2) \u2502 \u2502 \u2502 \u2502 input_value_str = pretty_print_arrow_table( \u2502 \u2502 input_value, num_head=half_lines, num_tail=h\u2026 \u2502 \u2502 ) \u2502 \u2502 else: \u2502 \u2502 input_value_str = pformat(input_value) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"pretty_string\", input_value_str) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f replace_string \u00b6 \u256d\u2500 Module: replace_string \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.ReplaceStringModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.replace_string \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.strings.ReplaceModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 replacement_map object A map, containing the \u2502 \u2502 strings to be replaced as \u2502 \u2502 keys, and the replacements \u2502 \u2502 as values. \u2502 \u2502 default_value string The default value to use \u2502 \u2502 if the string to be \u2502 \u2502 replaced is not in the \u2502 \u2502 replacement map. By \u2502 \u2502 default, this just returns \u2502 \u2502 the string itself. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 repl_map = self.get_config_value(\"replacement_map\") \u2502 \u2502 default = self.get_config_value(\"default_value\") \u2502 \u2502 \u2502 \u2502 if text not in repl_map.keys(): \u2502 \u2502 if default is None: \u2502 \u2502 result = text \u2502 \u2502 else: \u2502 \u2502 result = default \u2502 \u2502 else: \u2502 \u2502 result = repl_map[text] \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"text\", result) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Included modules"},{"location":"modules_list/#available-module-types","text":"This page contains a list of all available Kiara module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type.","title":"Available module types"},{"location":"modules_list/#add_nodes_to_network_graph","text":"\u256d\u2500 Module: add_nodes_to_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.AddNodesToNetwork\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Add nodes to an existing graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.add_nodes_to_network_graph \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 nodes_table_value = inputs.get_value_obj(\"node_attri\u2026 \u2502 \u2502 \u2502 \u2502 if nodes_table_value.is_none: \u2502 \u2502 # we return the graph as is \u2502 \u2502 # we are using the 'get_value_obj' method, becau\u2026 \u2502 \u2502 # actual data at all \u2502 \u2502 outputs.set_value(\"graph\", inputs.get_value_obj(\u2026 \u2502 \u2502 return \u2502 \u2502 \u2502 \u2502 input_graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 graph: Graph = copy.deepcopy(input_graph) \u2502 \u2502 \u2502 \u2502 nodes_table_obj: pyarrow.Table = nodes_table_value.g\u2026 \u2502 \u2502 nodes_table_index = inputs.get_value_data(\"index_col\u2026 \u2502 \u2502 \u2502 \u2502 attr_dict = ( \u2502 \u2502 nodes_table_obj.to_pandas() \u2502 \u2502 .set_index(nodes_table_index) \u2502 \u2502 .to_dict(\"index\") \u2502 \u2502 .items() \u2502 \u2502 ) \u2502 \u2502 graph.add_nodes_from(attr_dict) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"add_nodes_to_network_graph"},{"location":"modules_list/#and","text":"\u256d\u2500 Module: and \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.AndModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if both inputs are 'True'. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.and \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.delay) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value( \u2502 \u2502 \"y\", inputs.get_value_data(\"a\") and inputs.get_v\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"and"},{"location":"modules_list/#augment_network_graph","text":"\u256d\u2500 Module: augment_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.AugmentNetworkGra\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Augment an existing graph with node attributes. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.augment_network_graph \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 nodes_table_value = inputs.get_value_obj(\"node_attri\u2026 \u2502 \u2502 \u2502 \u2502 if nodes_table_value.is_none or not nodes_table_valu\u2026 \u2502 \u2502 # we return the graph as is \u2502 \u2502 # we are using the 'get_value_obj' method, becau\u2026 \u2502 \u2502 # actual data at all \u2502 \u2502 outputs.set_value(\"graph\", inputs.get_value_obj(\u2026 \u2502 \u2502 return \u2502 \u2502 \u2502 \u2502 input_graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 graph: Graph = copy.deepcopy(input_graph) \u2502 \u2502 \u2502 \u2502 nodes_table_obj: pyarrow.Table = nodes_table_value.g\u2026 \u2502 \u2502 nodes_table_index = inputs.get_value_data(\"index_col\u2026 \u2502 \u2502 if nodes_table_index not in nodes_table_obj.column_n\u2026 \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Node attribute table does not have a colum\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 attr_dict = ( \u2502 \u2502 nodes_table_obj.to_pandas() \u2502 \u2502 .set_index(nodes_table_index) \u2502 \u2502 .to_dict(\"index\") \u2502 \u2502 .items() \u2502 \u2502 ) \u2502 \u2502 graph.add_nodes_from(attr_dict) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"augment_network_graph"},{"location":"modules_list/#create_graph_from_edges_table","text":"\u256d\u2500 Module: create_graph_from_edges_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.CreateGraphFromEd\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Create a directed network graph object from tabular data. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_graph_from_edges_table \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.CreateGraphConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 graph_type string The type of the graph. If not \u2502 \u2502 specified, a 'graph_type' input \u2502 \u2502 field will be added which will \u2502 \u2502 default to 'directed'. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"graph_type\") is not None: \u2502 \u2502 _graph_type = self.get_config_value(\"graph_type\") \u2502 \u2502 else: \u2502 \u2502 _graph_type = inputs.get_value_data(\"graph_type\") \u2502 \u2502 \u2502 \u2502 graph_type = GraphTypesEnum[_graph_type] \u2502 \u2502 \u2502 \u2502 edges_table_value = inputs.get_value_obj(\"edges_tabl\u2026 \u2502 \u2502 edges_table_obj: pyarrow.Table = edges_table_value.g\u2026 \u2502 \u2502 \u2502 \u2502 source_column = inputs.get_value_data(\"source_column\u2026 \u2502 \u2502 target_column = inputs.get_value_data(\"target_column\u2026 \u2502 \u2502 weight_column = inputs.get_value_data(\"weight_column\u2026 \u2502 \u2502 \u2502 \u2502 errors = [] \u2502 \u2502 if source_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(source_column) \u2502 \u2502 if target_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(target_column) \u2502 \u2502 if weight_column not in edges_table_obj.column_names: \u2502 \u2502 errors.append(weight_column) \u2502 \u2502 \u2502 \u2502 if errors: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't create network graph, source table m\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 min_table = edges_table_obj.select( \u2502 \u2502 (source_column, target_column, weight_column) \u2502 \u2502 ) \u2502 \u2502 pandas_table = min_table.to_pandas() \u2502 \u2502 \u2502 \u2502 if graph_type != GraphTypesEnum.directed: \u2502 \u2502 raise NotImplementedError(\"Only 'directed' graph\u2026 \u2502 \u2502 graph_cls = nx.DiGraph \u2502 \u2502 \u2502 \u2502 graph: nx.DiGraph = nx.from_pandas_edgelist( \u2502 \u2502 pandas_table, \u2502 \u2502 source_column, \u2502 \u2502 target_column, \u2502 \u2502 edge_attr=True, \u2502 \u2502 create_using=graph_cls, \u2502 \u2502 ) \u2502 \u2502 outputs.set_value(\"graph\", graph) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"create_graph_from_edges_table"},{"location":"modules_list/#create_table_from_file","text":"\u256d\u2500 Module: create_table_from_file \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.CreateTableFromFileMo\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Import table-like data from an item in the data registry. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_table_from_file \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.CreateTableModuleConf\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 allow_column_filter boolean Whether to add an \u2502 \u2502 input option to \u2502 \u2502 filter columns. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_file: FileModel = inputs.get_value_data(\"file\") \u2502 \u2502 \u2502 \u2502 imported_data = pa.csv.read_csv(input_file.path) \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"allow_column_filter\"): \u2502 \u2502 if self.get_config_value(\"columns\"): \u2502 \u2502 imported_data = imported_data.select( \u2502 \u2502 self.get_config_value(\"only_columns\") \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", imported_data) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"create_table_from_file"},{"location":"modules_list/#create_table_from_text_files","text":"\u256d\u2500 Module: create_table_from_text_files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.CreateTableFromTextFi\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.create_table_from_text_files \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.CreateTableFromTextFi\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 columns array A list of columns to add to the \u2502 \u2502 table. Available properties: id, \u2502 \u2502 rel_path, orig_filename, \u2502 \u2502 orig_path, import_time, \u2502 \u2502 mime_type, size, content, path, \u2502 \u2502 file_name \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 bundle: FileBundleModel = inputs.get_value_data(\"fil\u2026 \u2502 \u2502 \u2502 \u2502 columns = self.get_config_value(\"columns\") \u2502 \u2502 if not columns: \u2502 \u2502 columns = DEFAULT_COLUMNS \u2502 \u2502 \u2502 \u2502 if \"content\" in columns: \u2502 \u2502 file_dict = bundle.read_text_file_contents() \u2502 \u2502 else: \u2502 \u2502 file_dict = {} \u2502 \u2502 for rel_path in bundle.included_files.keys(): \u2502 \u2502 file_dict[rel_path] = None # type: ignore \u2502 \u2502 \u2502 \u2502 tabular: typing.Dict[str, typing.List[typing.Any]] =\u2026 \u2502 \u2502 for column in columns: \u2502 \u2502 for index, rel_path in enumerate(sorted(file_dic\u2026 \u2502 \u2502 \u2502 \u2502 if column == \"content\": \u2502 \u2502 value: typing.Any = file_dict[rel_path] \u2502 \u2502 elif column == \"id\": \u2502 \u2502 value = index \u2502 \u2502 elif column == \"rel_path\": \u2502 \u2502 value = rel_path \u2502 \u2502 else: \u2502 \u2502 file_model = bundle.included_files[rel_p\u2026 \u2502 \u2502 value = getattr(file_model, column) \u2502 \u2502 \u2502 \u2502 tabular.setdefault(column, []).append(value) \u2502 \u2502 \u2502 \u2502 table = pa.Table.from_pydict(tabular) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", table) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"create_table_from_text_files"},{"location":"modules_list/#date_range_check","text":"\u256d\u2500 Module: date_range_check \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dates.DateRangeCheckModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether a date falls within a specified date range. \u2502 \u2502 \u2502 \u2502 At least one of the inputs 'earliest' or 'latest' must be \u2502 \u2502 set, it's allowed to set both, though. \u2502 \u2502 \u2502 \u2502 Return ``True`` if that's the case, otherwise ``False``. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.date_range_check \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 d = inputs.get_value_data(\"date\") \u2502 \u2502 earliest: typing.Optional[datetime.datetime] = input\u2026 \u2502 \u2502 latest: typing.Optional[datetime.datetime] = inputs.\u2026 \u2502 \u2502 \u2502 \u2502 if hasattr(d, \"as_py\"): \u2502 \u2502 d = d.as_py() \u2502 \u2502 \u2502 \u2502 if not earliest and not latest: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 \"Can't process date range check: need at lea\u2026 \u2502 \u2502 ) \u2502 \u2502 elif earliest and latest: \u2502 \u2502 matches = earliest <= d <= latest \u2502 \u2502 elif earliest: \u2502 \u2502 matches = earliest <= d \u2502 \u2502 else: \u2502 \u2502 matches = d <= latest \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"within_range\", matches) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"date_range_check"},{"location":"modules_list/#dummy","text":"\u256d\u2500 Module: dummy \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dev.DummyModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Module that simulates processing, but uses hard-coded \u2502 \u2502 outputs as a result. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.dummy \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.dev.DummyProcessingModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 doc string -- n/a -- \u2502 \u2502 input_schema object The input schema for this \u2502 \u2502 module. \u2502 \u2502 output_schema object The output schema for this \u2502 \u2502 module. \u2502 \u2502 outputs object The (dummy) output for this \u2502 \u2502 module. \u2502 \u2502 delay number The delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 (dummy) outputs are \u2502 \u2502 returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \"\"\"Returns the hardcoded output values that are set \u2026 \u2502 \u2502 \u2502 \u2502 Optionally, this module can simulate processing by w\u2026 \u2502 \u2502 \"\"\" \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 \u2502 \u2502 output_values: typing.Mapping = self.config.get(\"out\u2026 \u2502 \u2502 \u2502 \u2502 value_dict = {} \u2502 \u2502 for output_name in self.output_names: \u2502 \u2502 if output_name not in output_values.keys(): \u2502 \u2502 raise NotImplementedError() \u2502 \u2502 # v = self.output_schemas[output_name].type_\u2026 \u2502 \u2502 # value_dict[output_name] = v \u2502 \u2502 else: \u2502 \u2502 value_dict[output_name] = output_values[outp\u2026 \u2502 \u2502 outputs.set_values(**value_dict) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"dummy"},{"location":"modules_list/#extract_date","text":"\u256d\u2500 Module: extract_date \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.dates.ExtractDateModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.extract_date \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 \u2502 \u2502 date_match = re.findall(r\"_(\\d{4}-\\d{2}-\\d{2})_\", te\u2026 \u2502 \u2502 assert date_match \u2502 \u2502 \u2502 \u2502 d_obj = parser.parse(date_match[0]) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"date\", d_obj) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"extract_date"},{"location":"modules_list/#filter_table","text":"\u256d\u2500 Module: filter_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.FilterTableModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.filter_table \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.tabular_data.TableFilterModuleConf\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_table: pa.Table = inputs.get_value_data(\"table\u2026 \u2502 \u2502 filter_array: pa.Array = inputs.get_value_data(\"mask\u2026 \u2502 \u2502 \u2502 \u2502 filtered = input_table.filter(filter_array) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", filtered) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"filter_table"},{"location":"modules_list/#find_shortest_path","text":"\u256d\u2500 Module: find_shortest_path \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.FindShortestPathM\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Find the shortest path between two nodes in a graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.find_shortest_path \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.FindShortestPathM\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 mode string Whether to calculate one \u2502 \u2502 shortest path for only one pair \u2502 \u2502 ('single-pair'), or use two node \u2502 \u2502 lists as input and select one of \u2502 \u2502 the following strategies: \u2502 \u2502 shortest path for each pair \u2502 \u2502 ('one-to-one'), the shortest \u2502 \u2502 path to all targets \u2502 \u2502 ('one-to-many'), or a matrix of \u2502 \u2502 all possible combinations \u2502 \u2502 ('many-to-many'). \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 mode = self.get_config_value(\"mode\") \u2502 \u2502 if mode != \"single-pair\": \u2502 \u2502 raise NotImplementedError() \u2502 \u2502 \u2502 \u2502 graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 source: typing.Any = inputs.get_value_data(\"source_n\u2026 \u2502 \u2502 target: typing.Any = inputs.get_value_data(\"target_n\u2026 \u2502 \u2502 \u2502 \u2502 if source not in graph.nodes: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't process shortest path, source '{sour\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 if target not in graph.nodes: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't process shortest path, target '{targ\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 shortest_path = nx.shortest_path(graph, source=sourc\u2026 \u2502 \u2502 outputs.set_value(\"path\", shortest_path) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"find_shortest_path"},{"location":"modules_list/#graph_properties","text":"\u256d\u2500 Module: graph_properties \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.network_analysis.ExtractGraphPrope\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Extract inherent properties of a network graph. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.graph_properties \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.network_analysis.ExtractGraphPrope\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 find_largest_compon\u2026 boolean Find the largest \u2502 \u2502 component of a \u2502 \u2502 graph. \u2502 \u2502 number_of_nodes boolean Count the number of \u2502 \u2502 nodes. \u2502 \u2502 number_of_edges boolean Count the number of \u2502 \u2502 edges \u2502 \u2502 density boolean Calculate the graph \u2502 \u2502 density. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 graph: Graph = inputs.get_value_data(\"graph\") \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"find_largest_component\"): \u2502 \u2502 lc_graph = copy.deepcopy(graph) \u2502 \u2502 # largest_component = max(nx.strongly_connected_\u2026 \u2502 \u2502 lc_graph.remove_nodes_from( \u2502 \u2502 list(nx.isolates(lc_graph)) \u2502 \u2502 ) # remove unconnected nodes from graph \u2502 \u2502 lc_density = nx.density(lc_graph) \u2502 \u2502 outputs.set_values( \u2502 \u2502 largest_component=lc_graph, density_largest_\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"number_of_nodes\"): \u2502 \u2502 outputs.set_values(number_of_nodes=len(graph.nod\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"number_of_edges\"): \u2502 \u2502 outputs.set_values(number_of_edges=len(graph.edg\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"density\"): \u2502 \u2502 density = nx.density(graph) \u2502 \u2502 outputs.set_values(density=density) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"graph_properties"},{"location":"modules_list/#import_local_file","text":"\u256d\u2500 Module: import_local_file \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.data_onboarding.ImportLocalFileMod\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Read a file into the data registry. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.import_local_file \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.data_onboarding.ImportLocalPathCon\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 source_is_immutable boolean Whether the data that \u2502 \u2502 lives in source path \u2502 \u2502 can be relied upon to \u2502 \u2502 not change, and \u2502 \u2502 always be available \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 path = inputs.get_value_data(\"path\") \u2502 \u2502 file_model = FileModel.import_file(path) \u2502 \u2502 outputs.set_value(\"file\", file_model) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"import_local_file"},{"location":"modules_list/#import_local_folder","text":"\u256d\u2500 Module: import_local_folder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.data_onboarding.ImportLocalFolderM\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.import_local_folder \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.data_onboarding.ImportLocalPathCon\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for \u2502 \u2502 this module. \u2502 \u2502 source_is_immutable boolean Whether the data that \u2502 \u2502 lives in source path \u2502 \u2502 can be relied upon to \u2502 \u2502 not change, and \u2502 \u2502 always be available \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 path = inputs.get_value_data(\"path\") \u2502 \u2502 \u2502 \u2502 included_files = inputs.get_value_data(\"included_fil\u2026 \u2502 \u2502 excluded_dirs = inputs.get_value_data(\"excluded_dirs\u2026 \u2502 \u2502 \u2502 \u2502 import_config = FolderImportConfig( \u2502 \u2502 include_files=included_files, exclude_dirs=exclu\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 bundle = FileBundleModel.import_folder(source=path, \u2026 \u2502 \u2502 \u2502 \u2502 outputs.set_values(file_bundle=bundle) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"import_local_folder"},{"location":"modules_list/#included_in_list_check","text":"\u256d\u2500 Module: included_in_list_check \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.lists.IncludedInListCheckModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether an element is in a list. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.included_in_list_check \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 item_list = inputs.get_value_data(\"list\") \u2502 \u2502 item = inputs.get_value_data(\"item\") \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"is_included\", item in item_list) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"included_in_list_check"},{"location":"modules_list/#map","text":"\u256d\u2500 Module: map \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.array_data.MapModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Map a list of values into another list of values. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.map \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.array_data.MapModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 module_type string The name of the kiara module \u2502 \u2502 to use to filter the input \u2502 \u2502 data. \u2502 \u2502 module_config object The config for the kiara \u2502 \u2502 filter module. \u2502 \u2502 input_name string The name of the input name \u2502 \u2502 of the module which will \u2502 \u2502 receive the items from our \u2502 \u2502 input array. Can be omitted \u2502 \u2502 if the configured module \u2502 \u2502 only has a single input. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 input_array: pa.Array = inputs.get_value_data(\"array\u2026 \u2502 \u2502 \u2502 \u2502 module_name = self.get_config_value(\"module_type\") \u2502 \u2502 module_config = self.get_config_value(\"module_config\u2026 \u2502 \u2502 module_obj: KiaraModule = self._kiara.create_module( \u2502 \u2502 \"_map_module\", module_name, module_config=module\u2026 \u2502 \u2502 ) \u2502 \u2502 # TODO: validate that the selected module is appropr\u2026 \u2502 \u2502 assert len(list(module_obj.output_names)) == 1 \u2502 \u2502 \u2502 \u2502 module_output_name = list(module_obj.output_names)[0] \u2502 \u2502 \u2502 \u2502 init_data: typing.Dict[str, typing.Any] = {} \u2502 \u2502 for input_name in self.input_schemas.keys(): \u2502 \u2502 if input_name in [\"array\", self.module_input_nam\u2026 \u2502 \u2502 continue \u2502 \u2502 \u2502 \u2502 init_data[input_name] = inputs.get_value_obj(inp\u2026 \u2502 \u2502 \u2502 \u2502 multi_threaded = False \u2502 \u2502 if multi_threaded: \u2502 \u2502 \u2502 \u2502 def run_module(item): \u2502 \u2502 _d = copy.copy(init_data) \u2502 \u2502 assert self._module_input_name is not None \u2502 \u2502 _d[self._module_input_name] = item \u2502 \u2502 r = module_obj.run(**_d) \u2502 \u2502 return r.get_all_value_data() \u2502 \u2502 \u2502 \u2502 executor = ThreadPoolExecutor() \u2502 \u2502 results: typing.Any = executor.map(run_module, i\u2026 \u2502 \u2502 executor.shutdown(wait=True) \u2502 \u2502 \u2502 \u2502 else: \u2502 \u2502 results = [] \u2502 \u2502 for item in input_array: \u2502 \u2502 _d = copy.copy(init_data) \u2502 \u2502 assert self._module_input_name is not None \u2502 \u2502 _d[self._module_input_name] = item \u2502 \u2502 r = module_obj.run(**_d) \u2502 \u2502 results.append(r.get_all_value_data()) \u2502 \u2502 \u2502 \u2502 result_list = [] \u2502 \u2502 result_types = set() \u2502 \u2502 for r in results: \u2502 \u2502 r_item = r[module_output_name] # type: ignore \u2502 \u2502 result_list.append(r_item) \u2502 \u2502 result_types.add(type(r_item)) \u2502 \u2502 \u2502 \u2502 assert len(result_types) == 1 \u2502 \u2502 outputs.set_value(\"array\", pa.array(result_list)) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"map"},{"location":"modules_list/#match_regex","text":"\u256d\u2500 Module: match_regex \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.RegexModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Check whether the input string matches a provided regular \u2502 \u2502 expression. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.match_regex \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.strings.RegexModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 regex string The regex to apply. \u2502 \u2502 only_first_match boolean Whether to only return \u2502 \u2502 the first match, or all \u2502 \u2502 matches. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 regex = self.get_config_value(\"regex\") \u2502 \u2502 matches = re.findall(regex, text) \u2502 \u2502 \u2502 \u2502 if not matches: \u2502 \u2502 raise KiaraProcessingException(f\"No match for re\u2026 \u2502 \u2502 \u2502 \u2502 if self.get_config_value(\"only_first_match\"): \u2502 \u2502 result = matches[0] \u2502 \u2502 else: \u2502 \u2502 result = matches \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"text\", result) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"match_regex"},{"location":"modules_list/#merge_table","text":"\u256d\u2500 Module: merge_table \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.tabular_data.MergeTableModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.merge_table \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 sources = inputs.get_value_data(\"sources\") \u2502 \u2502 \u2502 \u2502 len_dict = {} \u2502 \u2502 arrays = [] \u2502 \u2502 column_names = [] \u2502 \u2502 for source_key, table_or_column in sources.items(): \u2502 \u2502 \u2502 \u2502 if isinstance(table_or_column, pa.Table): \u2502 \u2502 rows = table_or_column.num_rows \u2502 \u2502 for name in table_or_column.schema.names: \u2502 \u2502 column = table_or_column.column(name) \u2502 \u2502 arrays.append(column) \u2502 \u2502 column_names.append(name) \u2502 \u2502 \u2502 \u2502 elif isinstance(table_or_column, pa.Array): \u2502 \u2502 rows = len(table_or_column) \u2502 \u2502 arrays.append(table_or_column) \u2502 \u2502 column_names.append(source_key) \u2502 \u2502 else: \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't merge table: invalid type '{type\u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 len_dict[source_key] = rows \u2502 \u2502 \u2502 \u2502 all_rows = None \u2502 \u2502 for source_key, rows in len_dict.items(): \u2502 \u2502 if all_rows is None: \u2502 \u2502 all_rows = rows \u2502 \u2502 else: \u2502 \u2502 if all_rows != rows: \u2502 \u2502 all_rows = None \u2502 \u2502 break \u2502 \u2502 \u2502 \u2502 if all_rows is None: \u2502 \u2502 len_str = \"\" \u2502 \u2502 for name, rows in len_dict.items(): \u2502 \u2502 len_str = f\" {name} ({rows})\" \u2502 \u2502 \u2502 \u2502 raise KiaraProcessingException( \u2502 \u2502 f\"Can't merge table, sources have different \u2026 \u2502 \u2502 ) \u2502 \u2502 \u2502 \u2502 table = pa.Table.from_arrays(arrays=arrays, names=co\u2026 \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"table\", table) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"merge_table"},{"location":"modules_list/#not","text":"\u256d\u2500 Module: not \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.NotModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Negates the input. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.not \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \"\"\"Negates the input boolean.\"\"\" \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"y\", not inputs.get_value_data(\"a\"\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"not"},{"location":"modules_list/#or","text":"\u256d\u2500 Module: or \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.logic_gates.OrModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if one of the inputs is 'True'. \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.or \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.logic_gates.LogicProcessingModuleC\u2026 \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 delay number the delay in seconds from \u2502 \u2502 processing start to when the \u2502 \u2502 output is returned. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 time.sleep(self.config.get(\"delay\")) # type: ignore \u2502 \u2502 outputs.set_value(\"y\", inputs.get_value_data(\"a\") or\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"or"},{"location":"modules_list/#prepare_nodes_table_lena","text":"\u256d\u2500 Module: prepare_nodes_table_lena \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.scratchpad.PrepareNodesTableLenaMo\u2026 \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc Prepare tabular data so it can be used as a 'nodes_table' \u2502 \u2502 input in the a directed graph module. \u2502 \u2502 \u2502 \u2502 This is a very specific module, only accepting a very \u2502 \u2502 specific data format and as such only suitable as a \u2502 \u2502 proof-of-concept. \u2502 \u2502 Later on, this will be replaced by a more generic module \u2502 \u2502 (or pipeline). \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.prepare_nodes_table_lena \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 t: pyarrow.Table = inputs.get_value_data(\"table\") \u2502 \u2502 df = t.to_pandas() \u2502 \u2502 \u2502 \u2502 df1 = df.iloc[:, 0:11] \u2502 \u2502 df1.columns = [ \u2502 \u2502 \"Id\", \u2502 \u2502 \"LabelOrig\", \u2502 \u2502 \"LabelTrans\", \u2502 \u2502 \"Year\", \u2502 \u2502 \"Type\", \u2502 \u2502 \"Language\", \u2502 \u2502 \"City\", \u2502 \u2502 \"CountryOld\", \u2502 \u2502 \"CountryNew\", \u2502 \u2502 \"Latitude\", \u2502 \u2502 \"Longitude\", \u2502 \u2502 ] \u2502 \u2502 df2 = df.iloc[ \u2502 \u2502 :, 11: \u2502 \u2502 ] # This slices the dataframe in half creating a df\u2026 \u2502 \u2502 df2.columns = [ \u2502 \u2502 \"Id\", \u2502 \u2502 \"Year\", \u2502 \u2502 \"LabelOrig\", \u2502 \u2502 \"LabelTrans\", \u2502 \u2502 \"Type\", \u2502 \u2502 \"Language\", \u2502 \u2502 \"City\", \u2502 \u2502 \"CountryOld\", \u2502 \u2502 \"CountryNew\", \u2502 \u2502 \"Latitude\", \u2502 \u2502 \"Longitude\", \u2502 \u2502 ] \u2502 \u2502 extr_nodes = df1.append(df2) \u2502 \u2502 extr_nodes_unique = extr_nodes.drop_duplicates(subse\u2026 \u2502 \u2502 \u2502 \u2502 result = pyarrow.Table.from_pandas(extr_nodes_unique) \u2502 \u2502 outputs.set_values(table=result, index_column_name=\"\u2026 \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"prepare_nodes_table_lena"},{"location":"modules_list/#pretty_print","text":"\u256d\u2500 Module: pretty_print \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.PrettyPrintModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.pretty_print \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.KiaraModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this module. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 value_type = inputs.get_value_obj(\"item\").type_name \u2502 \u2502 input_value: Value = inputs.get_value_data(\"item\") \u2502 \u2502 \u2502 \u2502 max_lines = inputs.get_value_data(\"max_lines\") \u2502 \u2502 \u2502 \u2502 if value_type == \"table\": \u2502 \u2502 \u2502 \u2502 half_lines: typing.Optional[int] = None \u2502 \u2502 if max_lines: \u2502 \u2502 half_lines = int(max_lines / 2) \u2502 \u2502 \u2502 \u2502 input_value_str = pretty_print_arrow_table( \u2502 \u2502 input_value, num_head=half_lines, num_tail=h\u2026 \u2502 \u2502 ) \u2502 \u2502 else: \u2502 \u2502 input_value_str = pformat(input_value) \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"pretty_string\", input_value_str) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"pretty_print"},{"location":"modules_list/#replace_string","text":"\u256d\u2500 Module: replace_string \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara_modules.default.strings.ReplaceStringModule \u2502 \u2502 \u2502 \u2502 is pipeline no \u2502 \u2502 \u2502 \u2502 doc -- n/a -- \u2502 \u2502 \u2502 \u2502 source repo kiara_modules.default.replace_string \u2502 \u2502 \u2502 \u2502 config class kiara_modules.default.strings.ReplaceModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 replacement_map object A map, containing the \u2502 \u2502 strings to be replaced as \u2502 \u2502 keys, and the replacements \u2502 \u2502 as values. \u2502 \u2502 default_value string The default value to use \u2502 \u2502 if the string to be \u2502 \u2502 replaced is not in the \u2502 \u2502 replacement map. By \u2502 \u2502 default, this just returns \u2502 \u2502 the string itself. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src def process(self, inputs: ValueSet, outputs: ValueSet) -\u2026 \u2502 \u2502 \u2502 \u2502 text = inputs.get_value_data(\"text\") \u2502 \u2502 repl_map = self.get_config_value(\"replacement_map\") \u2502 \u2502 default = self.get_config_value(\"default_value\") \u2502 \u2502 \u2502 \u2502 if text not in repl_map.keys(): \u2502 \u2502 if default is None: \u2502 \u2502 result = text \u2502 \u2502 else: \u2502 \u2502 result = default \u2502 \u2502 else: \u2502 \u2502 result = repl_map[text] \u2502 \u2502 \u2502 \u2502 outputs.set_value(\"text\", result) \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"replace_string"},{"location":"pipelines_list/","text":"Available pipeline module types \u00b6 This page contains a list of all available Kiara pipeline module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type. import_network_graph \u00b6 \u256d\u2500 Module: import_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.ImportNetworkGraph \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Create a network graph from 2 tabular data sets: one that \u2502 \u2502 contains the edges, one that contains node attributes \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: import_local_file \u2502 \u2502 step_id: read_edges_file \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: import_local_file \u2502 \u2502 step_id: read_nodes_file \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: create_table \u2502 \u2502 step_id: load_edges_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 file: \u2502 \u2502 - step_id: read_edges_file \u2502 \u2502 value_name: file \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: create_table \u2502 \u2502 step_id: load_nodes_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 file: \u2502 \u2502 - step_id: read_nodes_file \u2502 \u2502 value_name: file \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: create_graph_from_edges_table \u2502 \u2502 step_id: create_graph \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 edges_table: \u2502 \u2502 - step_id: load_edges_table \u2502 \u2502 value_name: table \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: augment_network_graph \u2502 \u2502 step_id: augment_graph \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 graph: \u2502 \u2502 - step_id: create_graph \u2502 \u2502 value_name: graph \u2502 \u2502 sub_value: \u2502 \u2502 node_attributes: \u2502 \u2502 - step_id: load_nodes_table \u2502 \u2502 value_name: table \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 read_edges_file__path: edges_path \u2502 \u2502 read_nodes_file__path: nodes_path \u2502 \u2502 create_graph__source_column: source_column \u2502 \u2502 create_graph__target_column: target_column \u2502 \u2502 create_graph__weight_column: weight_column \u2502 \u2502 create_graph__graph_type: graph_type \u2502 \u2502 augment_graph__nodes_attributes: nodes_attributes \u2502 \u2502 augment_graph__index_column_name: nodes_table_index \u2502 \u2502 output_aliases: \u2502 \u2502 augment_graph__graph: graph \u2502 \u2502 doc: 'Create a network graph from 2 tabular data sets: o\u2026 \u2502 \u2502 one that contains node attributes' \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: import_network_graph \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f import_table_from_folder \u00b6 \u256d\u2500 Module: import_table_from_folder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.ImportTableFromFolder \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Create a table from a folder that contains text files. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: import_local_folder \u2502 \u2502 step_id: read_files_in_folder \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: create_table_from_text_files \u2502 \u2502 step_id: create_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 files: \u2502 \u2502 - step_id: read_files_in_folder \u2502 \u2502 value_name: file_bundle \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: auto \u2502 \u2502 output_aliases: auto \u2502 \u2502 doc: Create a table from a folder that contains text fil\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: import_table_from_folder \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f nand \u00b6 \u256d\u2500 Module: nand \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Nand \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'False' if both inputs are 'True'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: and \u2502 \u2502 step_id: and \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: not \u2502 \u2502 step_id: not \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: and \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 and__a: a \u2502 \u2502 and__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 not__y: y \u2502 \u2502 doc: Returns 'False' if both inputs are 'True'. \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: nand \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f network_analysis \u00b6 \u256d\u2500 Module: network_analysis \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.NetworkAnalysis \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc First iteration of a network analysis pipeline. This \u2502 \u2502 doesn't do much yet. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: find_shortest_path \u2502 \u2502 step_id: find_shortest_path \u2502 \u2502 module_config: \u2502 \u2502 mode: single-pair \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: graph_properties \u2502 \u2502 step_id: extract_properties \u2502 \u2502 module_config: \u2502 \u2502 density: false \u2502 \u2502 input_links: {} \u2502 \u2502 input_aliases: \u2502 \u2502 find_shortest_path__graph: graph \u2502 \u2502 extract_properties__graph: graph \u2502 \u2502 find_shortest_path__source_node: shortest_path_source_\u2026 \u2502 \u2502 find_shortest_path__target_node: shortest_path_target_\u2026 \u2502 \u2502 output_aliases: \u2502 \u2502 find_shortest_path__path: shortest_path \u2502 \u2502 extract_properties__largest_component: largest_compone\u2026 \u2502 \u2502 extract_properties__density_largest_component: density\u2026 \u2502 \u2502 extract_properties__number_of_nodes: number_of_nodes \u2502 \u2502 extract_properties__number_of_edges: number_of_edges \u2502 \u2502 doc: First iteration of a network analysis pipeline. Thi\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: network_analysis \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f nor \u00b6 \u256d\u2500 Module: nor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Nor \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if both inputs are 'False'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: or \u2502 \u2502 step_id: or \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: not \u2502 \u2502 step_id: not \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: or \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 or__a: a \u2502 \u2502 or__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 not__y: y \u2502 \u2502 doc: Returns 'True' if both inputs are 'False'. \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: nor \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f xor \u00b6 \u256d\u2500 Module: xor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Xor \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if exactly one of it's two inputs is \u2502 \u2502 'True'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: or \u2502 \u2502 step_id: or \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: nand \u2502 \u2502 step_id: nand \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: and \u2502 \u2502 step_id: and \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: or \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 b: \u2502 \u2502 - step_id: nand \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 or__a: a \u2502 \u2502 or__b: b \u2502 \u2502 nand__a: a \u2502 \u2502 nand__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 and__y: y \u2502 \u2502 doc: Returns 'True' if exactly one of it's two inputs is\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: xor \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"Included pipelines"},{"location":"pipelines_list/#available-pipeline-module-types","text":"This page contains a list of all available Kiara pipeline module types, and their details. Note The formatting here will be improved later on, for now this should be enough to get the important details of each module type.","title":"Available pipeline module types"},{"location":"pipelines_list/#import_network_graph","text":"\u256d\u2500 Module: import_network_graph \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.ImportNetworkGraph \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Create a network graph from 2 tabular data sets: one that \u2502 \u2502 contains the edges, one that contains node attributes \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: import_local_file \u2502 \u2502 step_id: read_edges_file \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: import_local_file \u2502 \u2502 step_id: read_nodes_file \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: create_table \u2502 \u2502 step_id: load_edges_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 file: \u2502 \u2502 - step_id: read_edges_file \u2502 \u2502 value_name: file \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: create_table \u2502 \u2502 step_id: load_nodes_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 file: \u2502 \u2502 - step_id: read_nodes_file \u2502 \u2502 value_name: file \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: create_graph_from_edges_table \u2502 \u2502 step_id: create_graph \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 edges_table: \u2502 \u2502 - step_id: load_edges_table \u2502 \u2502 value_name: table \u2502 \u2502 sub_value: \u2502 \u2502 - module_type: augment_network_graph \u2502 \u2502 step_id: augment_graph \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 graph: \u2502 \u2502 - step_id: create_graph \u2502 \u2502 value_name: graph \u2502 \u2502 sub_value: \u2502 \u2502 node_attributes: \u2502 \u2502 - step_id: load_nodes_table \u2502 \u2502 value_name: table \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 read_edges_file__path: edges_path \u2502 \u2502 read_nodes_file__path: nodes_path \u2502 \u2502 create_graph__source_column: source_column \u2502 \u2502 create_graph__target_column: target_column \u2502 \u2502 create_graph__weight_column: weight_column \u2502 \u2502 create_graph__graph_type: graph_type \u2502 \u2502 augment_graph__nodes_attributes: nodes_attributes \u2502 \u2502 augment_graph__index_column_name: nodes_table_index \u2502 \u2502 output_aliases: \u2502 \u2502 augment_graph__graph: graph \u2502 \u2502 doc: 'Create a network graph from 2 tabular data sets: o\u2026 \u2502 \u2502 one that contains node attributes' \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: import_network_graph \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"import_network_graph"},{"location":"pipelines_list/#import_table_from_folder","text":"\u256d\u2500 Module: import_table_from_folder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.ImportTableFromFolder \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Create a table from a folder that contains text files. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: import_local_folder \u2502 \u2502 step_id: read_files_in_folder \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: create_table_from_text_files \u2502 \u2502 step_id: create_table \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 files: \u2502 \u2502 - step_id: read_files_in_folder \u2502 \u2502 value_name: file_bundle \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: auto \u2502 \u2502 output_aliases: auto \u2502 \u2502 doc: Create a table from a folder that contains text fil\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: import_table_from_folder \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"import_table_from_folder"},{"location":"pipelines_list/#nand","text":"\u256d\u2500 Module: nand \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Nand \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'False' if both inputs are 'True'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: and \u2502 \u2502 step_id: and \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: not \u2502 \u2502 step_id: not \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: and \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 and__a: a \u2502 \u2502 and__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 not__y: y \u2502 \u2502 doc: Returns 'False' if both inputs are 'True'. \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: nand \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"nand"},{"location":"pipelines_list/#network_analysis","text":"\u256d\u2500 Module: network_analysis \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.NetworkAnalysis \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc First iteration of a network analysis pipeline. This \u2502 \u2502 doesn't do much yet. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: find_shortest_path \u2502 \u2502 step_id: find_shortest_path \u2502 \u2502 module_config: \u2502 \u2502 mode: single-pair \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: graph_properties \u2502 \u2502 step_id: extract_properties \u2502 \u2502 module_config: \u2502 \u2502 density: false \u2502 \u2502 input_links: {} \u2502 \u2502 input_aliases: \u2502 \u2502 find_shortest_path__graph: graph \u2502 \u2502 extract_properties__graph: graph \u2502 \u2502 find_shortest_path__source_node: shortest_path_source_\u2026 \u2502 \u2502 find_shortest_path__target_node: shortest_path_target_\u2026 \u2502 \u2502 output_aliases: \u2502 \u2502 find_shortest_path__path: shortest_path \u2502 \u2502 extract_properties__largest_component: largest_compone\u2026 \u2502 \u2502 extract_properties__density_largest_component: density\u2026 \u2502 \u2502 extract_properties__number_of_nodes: number_of_nodes \u2502 \u2502 extract_properties__number_of_edges: number_of_edges \u2502 \u2502 doc: First iteration of a network analysis pipeline. Thi\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: network_analysis \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"network_analysis"},{"location":"pipelines_list/#nor","text":"\u256d\u2500 Module: nor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Nor \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if both inputs are 'False'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: or \u2502 \u2502 step_id: or \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: not \u2502 \u2502 step_id: not \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: or \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 or__a: a \u2502 \u2502 or__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 not__y: y \u2502 \u2502 doc: Returns 'True' if both inputs are 'False'. \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: nor \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"nor"},{"location":"pipelines_list/#xor","text":"\u256d\u2500 Module: xor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502 \u2502 \u2502 class kiara.modules.pipelines.Xor \u2502 \u2502 \u2502 \u2502 is pipeline yes \u2502 \u2502 \u2502 \u2502 doc Returns 'True' if exactly one of it's two inputs is \u2502 \u2502 'True'. \u2502 \u2502 \u2502 \u2502 source repo -- n/a -- \u2502 \u2502 \u2502 \u2502 config class kiara.module_config.PipelineModuleConfig \u2502 \u2502 \u2502 \u2502 config \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 constants object Value constants for this \u2502 \u2502 module. \u2502 \u2502 steps array A list of steps/modules \u2502 \u2502 of this pipeline, and \u2502 \u2502 their connections. \u2502 \u2502 input_aliases -- n/a -- A map of input aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<input_name> \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow input alias) as \u2502 \u2502 value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 output_aliases -- n/a -- A map of output aliases, \u2502 \u2502 with the calculated \u2502 \u2502 (<step_id>__<output_nam\u2026 \u2502 \u2502 -- double underscore!) \u2502 \u2502 name as key, and a \u2502 \u2502 string (the resulting \u2502 \u2502 workflow output alias) \u2502 \u2502 as value. Check the \u2502 \u2502 documentation for the \u2502 \u2502 config class for which \u2502 \u2502 marker strings can be \u2502 \u2502 used to automatically \u2502 \u2502 create this map if \u2502 \u2502 possible. \u2502 \u2502 doc string Documentation about what \u2502 \u2502 the pipeline does. \u2502 \u2502 meta object Metadata for this \u2502 \u2502 workflow. \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 src constants: {} \u2502 \u2502 steps: \u2502 \u2502 - module_type: or \u2502 \u2502 step_id: or \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: nand \u2502 \u2502 step_id: nand \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: {} \u2502 \u2502 - module_type: and \u2502 \u2502 step_id: and \u2502 \u2502 module_config: {} \u2502 \u2502 input_links: \u2502 \u2502 a: \u2502 \u2502 - step_id: or \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 b: \u2502 \u2502 - step_id: nand \u2502 \u2502 value_name: y \u2502 \u2502 sub_value: \u2502 \u2502 input_aliases: \u2502 \u2502 or__a: a \u2502 \u2502 or__b: b \u2502 \u2502 nand__a: a \u2502 \u2502 nand__b: b \u2502 \u2502 output_aliases: \u2502 \u2502 and__y: y \u2502 \u2502 doc: Returns 'True' if exactly one of it's two inputs is\u2026 \u2502 \u2502 meta: {} \u2502 \u2502 module_type_name: xor \u2502 \u2502 \u2502 \u2502 \u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f","title":"xor"},{"location":"usage/","text":"Usage \u00b6 TO BE DONE","title":"Usage"},{"location":"usage/#usage","text":"TO BE DONE","title":"Usage"},{"location":"api_reference/kiara_modules.default.array_data/","text":"kiara_modules.default.array_data \u00b6 MapModule \u00b6 Map a list of values into another list of values. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/array_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/array_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs module_instance_doc ( self ) \u00b6 Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in default/array_data.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( \"id\" , module_type = module_type , module_config = module_config ) doc = m . doc () link = m . source_link () if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/array_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_array : pa . Array = inputs . get_value_data ( \"array\" ) module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) module_obj : KiaraModule = self . _kiara . create_module ( \"_map_module\" , module_name , module_config = module_config ) # TODO: validate that the selected module is appropriate assert len ( list ( module_obj . output_names )) == 1 module_output_name = list ( module_obj . output_names )[ 0 ] init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) multi_threaded = False if multi_threaded : def run_module ( item ): _d = copy . copy ( init_data ) assert self . _module_input_name is not None _d [ self . _module_input_name ] = item r = module_obj . run ( ** _d ) return r . get_all_value_data () executor = ThreadPoolExecutor () results : typing . Any = executor . map ( run_module , input_array ) executor . shutdown ( wait = True ) else : results = [] for item in input_array : _d = copy . copy ( init_data ) assert self . _module_input_name is not None _d [ self . _module_input_name ] = item r = module_obj . run ( ** _d ) results . append ( r . get_all_value_data ()) result_list = [] result_types = set () for r in results : r_item = r [ module_output_name ] # type: ignore result_list . append ( r_item ) result_types . add ( type ( r_item )) assert len ( result_types ) == 1 outputs . set_value ( \"array\" , pa . array ( result_list )) MapModuleConfig pydantic-model \u00b6 input_name : str pydantic-field \u00b6 The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input. module_config : Dict [ str , Any ] pydantic-field \u00b6 The config for the kiara filter module. module_type : str pydantic-field required \u00b6 The name of the kiara module to use to filter the input data.","title":"\u279c\u2007array_data"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modulesdefaultarray_data","text":"","title":"kiara_modules.default.array_data"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModule","text":"Map a list of values into another list of values.","title":"MapModule"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/array_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ] = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"The array containing the values the filter is applied on.\" , } } for input_name , schema in self . child_module . input_schemas . items (): assert input_name != \"array\" if input_name == self . module_input_name : continue inputs [ input_name ] = schema return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/array_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"array\" : { \"type\" : \"array\" , \"doc\" : \"An array of equal length to the input array, containing the 'mapped' values.\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModule.module_instance_doc","text":"Return documentation for this instance of the module. If not overwritten, will return this class' method doc() . Source code in default/array_data.py def module_instance_doc ( self ) -> str : config : MapModuleConfig = self . config # type: ignore module_type = config . module_type module_config = config . module_config m = self . _kiara . create_module ( \"id\" , module_type = module_type , module_config = module_config ) doc = m . doc () link = m . source_link () if not link : link_str = f \"`` { module_type } ``\" else : link_str = f \"[`` { module_type } ``]( { link } )\" result = f \"\"\"Map the values of the input list onto a new list of the same length, using the { link_str } module.\"\"\" if doc and doc != \"-- n/a --\" : result = result + f \" \\n\\n `` { module_type } `` documentation: \\n\\n { doc } \" return result","title":"module_instance_doc()"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/array_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_array : pa . Array = inputs . get_value_data ( \"array\" ) module_name = self . get_config_value ( \"module_type\" ) module_config = self . get_config_value ( \"module_config\" ) module_obj : KiaraModule = self . _kiara . create_module ( \"_map_module\" , module_name , module_config = module_config ) # TODO: validate that the selected module is appropriate assert len ( list ( module_obj . output_names )) == 1 module_output_name = list ( module_obj . output_names )[ 0 ] init_data : typing . Dict [ str , typing . Any ] = {} for input_name in self . input_schemas . keys (): if input_name in [ \"array\" , self . module_input_name ]: continue init_data [ input_name ] = inputs . get_value_obj ( input_name ) multi_threaded = False if multi_threaded : def run_module ( item ): _d = copy . copy ( init_data ) assert self . _module_input_name is not None _d [ self . _module_input_name ] = item r = module_obj . run ( ** _d ) return r . get_all_value_data () executor = ThreadPoolExecutor () results : typing . Any = executor . map ( run_module , input_array ) executor . shutdown ( wait = True ) else : results = [] for item in input_array : _d = copy . copy ( init_data ) assert self . _module_input_name is not None _d [ self . _module_input_name ] = item r = module_obj . run ( ** _d ) results . append ( r . get_all_value_data ()) result_list = [] result_types = set () for r in results : r_item = r [ module_output_name ] # type: ignore result_list . append ( r_item ) result_types . add ( type ( r_item )) assert len ( result_types ) == 1 outputs . set_value ( \"array\" , pa . array ( result_list ))","title":"process()"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModuleConfig","text":"","title":"MapModuleConfig"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModuleConfig.input_name","text":"The name of the input name of the module which will receive the items from our input array. Can be omitted if the configured module only has a single input.","title":"input_name"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModuleConfig.module_config","text":"The config for the kiara filter module.","title":"module_config"},{"location":"api_reference/kiara_modules.default.array_data/#kiara_modules.default.array_data.MapModuleConfig.module_type","text":"The name of the kiara module to use to filter the input data.","title":"module_type"},{"location":"api_reference/kiara_modules.default.data_onboarding/","text":"kiara_modules.default.data_onboarding \u00b6 ImportLocalFileModule \u00b6 Read a file into the data registry. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/data_onboarding.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/data_onboarding.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/data_onboarding.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) file_model = FileModel . import_file ( path ) outputs . set_value ( \"file\" , file_model ) ImportLocalFolderModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/data_onboarding.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder.\" }, \"included_files\" : { \"type\" : \"array\" , \"doc\" : \"A list of strings, include all files where the filename ends with that string.\" , \"optional\" : True , }, \"excluded_dirs\" : { \"type\" : \"array\" , \"doc\" : \"A list of strings, exclude all folders whose name ends with that string.\" , \"optional\" : True , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/data_onboarding.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/data_onboarding.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) included_files = inputs . get_value_data ( \"included_files\" ) excluded_dirs = inputs . get_value_data ( \"excluded_dirs\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs ) bundle = FileBundleModel . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle ) ImportLocalPathConfig pydantic-model \u00b6 source_is_immutable : bool pydantic-field \u00b6 Whether the data that lives in source path can be relied upon to not change, and always be available","title":"\u279c\u2007data_onboarding"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modulesdefaultdata_onboarding","text":"","title":"kiara_modules.default.data_onboarding"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFileModule","text":"Read a file into the data registry.","title":"ImportLocalFileModule"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFileModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/data_onboarding.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the file.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFileModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/data_onboarding.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file\" : { \"type\" : \"file\" , \"doc\" : \"A representation of the original file content in the kiara data registry.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFileModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/data_onboarding.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) file_model = FileModel . import_file ( path ) outputs . set_value ( \"file\" , file_model )","title":"process()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFolderModule","text":"","title":"ImportLocalFolderModule"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFolderModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/data_onboarding.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"path\" : { \"type\" : \"string\" , \"doc\" : \"The path to the folder.\" }, \"included_files\" : { \"type\" : \"array\" , \"doc\" : \"A list of strings, include all files where the filename ends with that string.\" , \"optional\" : True , }, \"excluded_dirs\" : { \"type\" : \"array\" , \"doc\" : \"A list of strings, exclude all folders whose name ends with that string.\" , \"optional\" : True , }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFolderModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/data_onboarding.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"file_bundle\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The collection of files contained in the bundle.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalFolderModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/data_onboarding.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : path = inputs . get_value_data ( \"path\" ) included_files = inputs . get_value_data ( \"included_files\" ) excluded_dirs = inputs . get_value_data ( \"excluded_dirs\" ) import_config = FolderImportConfig ( include_files = included_files , exclude_dirs = excluded_dirs ) bundle = FileBundleModel . import_folder ( source = path , import_config = import_config ) outputs . set_values ( file_bundle = bundle )","title":"process()"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalPathConfig","text":"","title":"ImportLocalPathConfig"},{"location":"api_reference/kiara_modules.default.data_onboarding/#kiara_modules.default.data_onboarding.ImportLocalPathConfig.source_is_immutable","text":"Whether the data that lives in source path can be relied upon to not change, and always be available","title":"source_is_immutable"},{"location":"api_reference/kiara_modules.default.dates/","text":"kiara_modules.default.dates \u00b6 A collection of date related modules. Most of those are very bare-bones, not really dealing with more advanced (but very important) concepts like timezones and resolution yet. DateRangeCheckModule \u00b6 Check whether a date falls within a specified date range. At least one of the inputs 'earliest' or 'latest' must be set, it's allowed to set both, though. Return True if that's the case, otherwise False . create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/dates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/dates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/dates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if hasattr ( d , \"as_py\" ): d = d . as_py () if not earliest and not latest : raise KiaraProcessingException ( \"Can't process date range check: need at least one of 'earliest' or 'latest'\" ) elif earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches ) ExtractDateModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/dates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/dates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/dates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj )","title":"\u279c\u2007dates"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modulesdefaultdates","text":"A collection of date related modules. Most of those are very bare-bones, not really dealing with more advanced (but very important) concepts like timezones and resolution yet.","title":"kiara_modules.default.dates"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.DateRangeCheckModule","text":"Check whether a date falls within a specified date range. At least one of the inputs 'earliest' or 'latest' must be set, it's allowed to set both, though. Return True if that's the case, otherwise False .","title":"DateRangeCheckModule"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.DateRangeCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/dates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date to check.\" }, \"earliest\" : { \"type\" : \"date\" , \"doc\" : \"The earliest date that is allowed.\" , \"optional\" : True , }, \"latest\" : { \"type\" : \"date\" , \"doc\" : \"The latest date that is allowed.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.DateRangeCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/dates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"within_range\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean indicating whether the provided date was within the allowed range ('true'), or not ('false')\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.DateRangeCheckModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/dates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : d = inputs . get_value_data ( \"date\" ) earliest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"earliest\" ) latest : typing . Optional [ datetime . datetime ] = inputs . get_value_data ( \"latest\" ) if hasattr ( d , \"as_py\" ): d = d . as_py () if not earliest and not latest : raise KiaraProcessingException ( \"Can't process date range check: need at least one of 'earliest' or 'latest'\" ) elif earliest and latest : matches = earliest <= d <= latest elif earliest : matches = earliest <= d else : matches = d <= latest outputs . set_value ( \"within_range\" , matches )","title":"process()"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.ExtractDateModule","text":"","title":"ExtractDateModule"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.ExtractDateModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/dates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.ExtractDateModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/dates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"date\" : { \"type\" : \"date\" , \"doc\" : \"The date extracted from the input string.\" } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.dates/#kiara_modules.default.dates.ExtractDateModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/dates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) date_match = re . findall ( r \"_(\\d {4} -\\d {2} -\\d {2} )_\" , text ) assert date_match d_obj = parser . parse ( date_match [ 0 ]) # type: ignore outputs . set_value ( \"date\" , d_obj )","title":"process()"},{"location":"api_reference/kiara_modules.default.defaults/","text":"kiara_modules.default.defaults \u00b6 KIARA_MODULES_DEFAULT_MODULE_BASE_FOLDER \u00b6 Marker to indicate the base folder for the kiara_modules_default module. KIARA_MODULES_DEFAULT_RESOURCES_FOLDER \u00b6 Default resources folder for this package.","title":"\u279c\u2007defaults"},{"location":"api_reference/kiara_modules.default.defaults/#kiara_modulesdefaultdefaults","text":"","title":"kiara_modules.default.defaults"},{"location":"api_reference/kiara_modules.default.defaults/#kiara_modules.default.defaults.KIARA_MODULES_DEFAULT_MODULE_BASE_FOLDER","text":"Marker to indicate the base folder for the kiara_modules_default module.","title":"KIARA_MODULES_DEFAULT_MODULE_BASE_FOLDER"},{"location":"api_reference/kiara_modules.default.defaults/#kiara_modules.default.defaults.KIARA_MODULES_DEFAULT_RESOURCES_FOLDER","text":"Default resources folder for this package.","title":"KIARA_MODULES_DEFAULT_RESOURCES_FOLDER"},{"location":"api_reference/kiara_modules.default.dev/","text":"kiara_modules.default.dev \u00b6 Modules that are useful for kiara as well as pipeline-development, as well as testing. DummyModule \u00b6 Module that simulates processing, but uses hard-coded outputs as a result. create_input_schema ( self ) \u00b6 The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in default/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result create_output_schema ( self ) \u00b6 The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in default/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result process ( self , inputs , outputs ) \u00b6 Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in default/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict ) DummyProcessingModuleConfig pydantic-model \u00b6 Configuration for the 'dummy' processing module. delay : float pydantic-field \u00b6 The delay in seconds from processing start to when the (dummy) outputs are returned. input_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The input schema for this module. output_schema : Dict [ str , Dict ] pydantic-field required \u00b6 The output schema for this module. outputs : Dict [ str , Any ] pydantic-field \u00b6 The (dummy) output for this module.","title":"\u279c\u2007dev"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modulesdefaultdev","text":"Modules that are useful for kiara as well as pipeline-development, as well as testing.","title":"kiara_modules.default.dev"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyModule","text":"Module that simulates processing, but uses hard-coded outputs as a result.","title":"DummyModule"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyModule.create_input_schema","text":"The input schema for the dummy module is created at object creation time from the input_schemas config parameter. Source code in default/dev.py def create_input_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The input schema for the ``dummy`` module is created at object creation time from the ``input_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"input_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyModule.create_output_schema","text":"The output schema for the dummy module is created at object creation time from the output_schemas config parameter. Source code in default/dev.py def create_output_schema ( self ) -> typing . Mapping [ str , ValueSchema ]: \"\"\"The output schema for the ``dummy`` module is created at object creation time from the ``output_schemas`` config parameter.\"\"\" result = {} for k , v in self . config . get ( \"output_schema\" ) . items (): # type: ignore schema = ValueSchema ( ** v ) schema . validate_types ( self . _kiara ) result [ k ] = schema return result","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyModule.process","text":"Returns the hardcoded output values that are set in the outputs config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the delay config parameter). Source code in default/dev.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Returns the hardcoded output values that are set in the ``outputs`` config field. Optionally, this module can simulate processing by waiting a configured amount of time (seconds -- specified in the ``delay`` config parameter). \"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore output_values : typing . Mapping = self . config . get ( \"outputs\" ) # type: ignore value_dict = {} for output_name in self . output_names : if output_name not in output_values . keys (): raise NotImplementedError () # v = self.output_schemas[output_name].type_obj.fake_value() # value_dict[output_name] = v else : value_dict [ output_name ] = output_values [ output_name ] outputs . set_values ( ** value_dict )","title":"process()"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyProcessingModuleConfig","text":"Configuration for the 'dummy' processing module.","title":"DummyProcessingModuleConfig"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyProcessingModuleConfig.delay","text":"The delay in seconds from processing start to when the (dummy) outputs are returned.","title":"delay"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyProcessingModuleConfig.input_schema","text":"The input schema for this module.","title":"input_schema"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyProcessingModuleConfig.output_schema","text":"The output schema for this module.","title":"output_schema"},{"location":"api_reference/kiara_modules.default.dev/#kiara_modules.default.dev.DummyProcessingModuleConfig.outputs","text":"The (dummy) output for this module.","title":"outputs"},{"location":"api_reference/kiara_modules.default.lists/","text":"kiara_modules.default.lists \u00b6 IncludedInListCheckModule \u00b6 Check whether an element is in a list. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/lists.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/lists.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/lists.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"\u279c\u2007lists"},{"location":"api_reference/kiara_modules.default.lists/#kiara_modulesdefaultlists","text":"","title":"kiara_modules.default.lists"},{"location":"api_reference/kiara_modules.default.lists/#kiara_modules.default.lists.IncludedInListCheckModule","text":"Check whether an element is in a list.","title":"IncludedInListCheckModule"},{"location":"api_reference/kiara_modules.default.lists/#kiara_modules.default.lists.IncludedInListCheckModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/lists.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"list\" : { \"type\" : \"list\" , \"doc\" : \"The list.\" }, \"item\" : { \"type\" : \"any\" , \"doc\" : \"The element to check for inclusion in the list.\" , }, } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.lists/#kiara_modules.default.lists.IncludedInListCheckModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/lists.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"is_included\" : { \"type\" : \"boolean\" , \"doc\" : \"Whether the element is in the list, or not.\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.lists/#kiara_modules.default.lists.IncludedInListCheckModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/lists.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : item_list = inputs . get_value_data ( \"list\" ) item = inputs . get_value_data ( \"item\" ) outputs . set_value ( \"is_included\" , item in item_list )","title":"process()"},{"location":"api_reference/kiara_modules.default.logic_gates/","text":"kiara_modules.default.logic_gates \u00b6 AndModule \u00b6 Returns 'True' if both inputs are 'True'. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) ) LogicProcessingModuleConfig pydantic-model \u00b6 Config class for all the 'logic'-related modules. delay : float pydantic-field \u00b6 the delay in seconds from processing start to when the output is returned. NotModule \u00b6 Negates the input. create_input_schema ( self ) \u00b6 The not module only has one input, a boolean that will be negated by the module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } } create_output_schema ( self ) \u00b6 The output of this module is a single boolean, the negated input. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Negates the input boolean. Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" )) OrModule \u00b6 Returns 'True' if one of the inputs is 'True'. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"\u279c\u2007logic_gates"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modulesdefaultlogic_gates","text":"","title":"kiara_modules.default.logic_gates"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.AndModule","text":"Returns 'True' if both inputs are 'True'.","title":"AndModule"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.AndModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.AndModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.AndModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . delay ) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) and inputs . get_value_data ( \"b\" ) )","title":"process()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.LogicProcessingModuleConfig","text":"Config class for all the 'logic'-related modules.","title":"LogicProcessingModuleConfig"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.LogicProcessingModuleConfig.delay","text":"the delay in seconds from processing start to when the output is returned.","title":"delay"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.NotModule","text":"Negates the input.","title":"NotModule"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.NotModule.create_input_schema","text":"The not module only has one input, a boolean that will be negated by the module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The not module only has one input, a boolean that will be negated by the module.\"\"\" return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" } }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.NotModule.create_output_schema","text":"The output of this module is a single boolean, the negated input. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: \"\"\"The output of this module is a single boolean, the negated input.\"\"\" return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.NotModule.process","text":"Negates the input boolean. Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : \"\"\"Negates the input boolean.\"\"\" time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , not inputs . get_value_data ( \"a\" ))","title":"process()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.OrModule","text":"Returns 'True' if one of the inputs is 'True'.","title":"OrModule"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.OrModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/logic_gates.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"a\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, \"b\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing this input state.\" }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.OrModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/logic_gates.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"y\" : { \"type\" : \"boolean\" , \"doc\" : \"A boolean describing the module output state.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.logic_gates/#kiara_modules.default.logic_gates.OrModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/logic_gates.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : time . sleep ( self . config . get ( \"delay\" )) # type: ignore outputs . set_value ( \"y\" , inputs . get_value_data ( \"a\" ) or inputs . get_value_data ( \"b\" ))","title":"process()"},{"location":"api_reference/kiara_modules.default/","text":"kiara_modules.default \u00b6 log \u00b6 Top-level package for kiara_modules.default.","title":"kiara_modules.default"},{"location":"api_reference/kiara_modules.default/#kiara_modulesdefault","text":"","title":"kiara_modules.default"},{"location":"api_reference/kiara_modules.default/#kiara_modules.default.__init__.log","text":"Top-level package for kiara_modules.default.","title":"log"},{"location":"api_reference/kiara_modules.default.network_analysis/","text":"kiara_modules.default.network_analysis \u00b6 AddNodesToNetworkGraphModule \u00b6 Add nodes to an existing graph. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"The table containing node attributes.\" , \"optional\" : True , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node index in the node attributes table.\" , \"optional\" : True , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }} process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : nodes_table_value = inputs . get_value_obj ( \"node_attributes\" ) if nodes_table_value . is_none : # we return the graph as is # we are using the 'get_value_obj' method, because there is no need to retrieve the # actual data at all outputs . set_value ( \"graph\" , inputs . get_value_obj ( \"graph\" )) return input_graph : Graph = inputs . get_value_data ( \"graph\" ) graph : Graph = copy . deepcopy ( input_graph ) nodes_table_obj : pyarrow . Table = nodes_table_value . get_value_data () nodes_table_index = inputs . get_value_data ( \"index_column_name\" ) attr_dict = ( nodes_table_obj . to_pandas () . set_index ( nodes_table_index ) . to_dict ( \"index\" ) . items () ) graph . add_nodes_from ( attr_dict ) outputs . set_value ( \"graph\" , graph ) AugmentNetworkGraphModule \u00b6 Augment an existing graph with node attributes. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"node_attributes\" : { \"type\" : \"table\" , \"doc\" : \"The table containing node attributes.\" , \"optional\" : True , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node index in the node attributes table.\" , \"optional\" : True , }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }} process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : nodes_table_value = inputs . get_value_obj ( \"node_attributes\" ) if nodes_table_value . is_none or not nodes_table_value : # we return the graph as is # we are using the 'get_value_obj' method, because there is no need to retrieve the # actual data at all outputs . set_value ( \"graph\" , inputs . get_value_obj ( \"graph\" )) return input_graph : Graph = inputs . get_value_data ( \"graph\" ) graph : Graph = copy . deepcopy ( input_graph ) nodes_table_obj : pyarrow . Table = nodes_table_value . get_value_data () nodes_table_index = inputs . get_value_data ( \"index_column_name\" ) if nodes_table_index not in nodes_table_obj . column_names : raise KiaraProcessingException ( f \"Node attribute table does not have a column with (index) name ' { nodes_table_index } '. Available column names: { ', ' . join ( nodes_table_obj . column_names ) } \" ) attr_dict = ( nodes_table_obj . to_pandas () . set_index ( nodes_table_index ) . to_dict ( \"index\" ) . items () ) graph . add_nodes_from ( attr_dict ) outputs . set_value ( \"graph\" , graph ) CreateGraphConfig pydantic-model \u00b6 graph_type : str pydantic-field \u00b6 The type of the graph. If not specified, a 'graph_type' input field will be added which will default to 'directed'. CreateGraphFromEdgesTableModule \u00b6 Create a directed network graph object from tabular data. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"edges_table\" : { \"type\" : \"table\" , \"doc\" : \"The table to extract the edges from.\" , }, \"source_column\" : { \"type\" : \"string\" , \"default\" : \"source\" , \"doc\" : \"The name of the column that contains the edge source in edges table.\" , }, \"target_column\" : { \"type\" : \"string\" , \"default\" : \"target\" , \"doc\" : \"The name of the column that contains the edge target in the edges table.\" , }, \"weight_column\" : { \"type\" : \"string\" , \"default\" : \"weight\" , \"doc\" : \"The name of the column that contains the edge weight in edges table.\" , }, } if self . get_config_value ( \"graph_type\" ) is None : inputs [ \"graph_type\" ] = { \"type\" : \"string\" , \"default\" : \"directed\" , \"doc\" : \"The type of the graph. Allowed: 'undirected', 'directed', 'multi_directed', 'multi_undirected'.\" , } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The (networkx) graph object.\" }, } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : if self . get_config_value ( \"graph_type\" ) is not None : _graph_type = self . get_config_value ( \"graph_type\" ) else : _graph_type = inputs . get_value_data ( \"graph_type\" ) graph_type = GraphTypesEnum [ _graph_type ] edges_table_value = inputs . get_value_obj ( \"edges_table\" ) edges_table_obj : pyarrow . Table = edges_table_value . get_value_data () source_column = inputs . get_value_data ( \"source_column\" ) target_column = inputs . get_value_data ( \"target_column\" ) weight_column = inputs . get_value_data ( \"weight_column\" ) errors = [] if source_column not in edges_table_obj . column_names : errors . append ( source_column ) if target_column not in edges_table_obj . column_names : errors . append ( target_column ) if weight_column not in edges_table_obj . column_names : errors . append ( weight_column ) if errors : raise KiaraProcessingException ( f \"Can't create network graph, source table missing column(s): { ', ' . join ( errors ) } . Available columns: { ', ' . join ( edges_table_obj . column_names ) } .\" ) min_table = edges_table_obj . select ( ( source_column , target_column , weight_column ) ) pandas_table = min_table . to_pandas () if graph_type != GraphTypesEnum . directed : raise NotImplementedError ( \"Only 'directed' graphs supported at the moment.\" ) graph_cls = nx . DiGraph graph : nx . DiGraph = nx . from_pandas_edgelist ( pandas_table , source_column , target_column , edge_attr = True , create_using = graph_cls , ) outputs . set_value ( \"graph\" , graph ) ExtractGraphPropertiesModule \u00b6 Extract inherent properties of a network graph. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_graph\" , \"doc\" : \"A sub-graph of the largest component of the graph.\" , } result [ \"density_largest_component\" ] = { \"type\" : \"float\" , \"doc\" : \"The density of the largest component.\" , } if self . get_config_value ( \"number_of_nodes\" ): result [ \"number_of_nodes\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of nodes in the graph.\" , } if self . get_config_value ( \"number_of_edges\" ): result [ \"number_of_edges\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of edges in the graph.\" , } if self . get_config_value ( \"density\" ): result [ \"density\" ] = { \"type\" : \"float\" , \"doc\" : \"The density of the graph.\" } return result process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : graph : Graph = inputs . get_value_data ( \"graph\" ) if self . get_config_value ( \"find_largest_component\" ): lc_graph = copy . deepcopy ( graph ) # largest_component = max(nx.strongly_connected_components_recursive(lc_graph), key=len) lc_graph . remove_nodes_from ( list ( nx . isolates ( lc_graph )) ) # remove unconnected nodes from graph lc_density = nx . density ( lc_graph ) outputs . set_values ( largest_component = lc_graph , density_largest_component = lc_density ) if self . get_config_value ( \"number_of_nodes\" ): outputs . set_values ( number_of_nodes = len ( graph . nodes )) if self . get_config_value ( \"number_of_edges\" ): outputs . set_values ( number_of_edges = len ( graph . edges )) if self . get_config_value ( \"density\" ): density = nx . density ( graph ) outputs . set_values ( density = density ) ExtractGraphPropertiesModuleConfig pydantic-model \u00b6 density : bool pydantic-field \u00b6 Calculate the graph density. find_largest_component : bool pydantic-field \u00b6 Find the largest component of a graph. number_of_edges : bool pydantic-field \u00b6 Count the number of edges number_of_nodes : bool pydantic-field \u00b6 Count the number of nodes. FindShortestPathModule \u00b6 Find the shortest path between two nodes in a graph. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, } create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"array\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"table\" , \"doc\" : \"A table with 'source', 'target' and 'path' column.\" , } } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () graph : Graph = inputs . get_value_data ( \"graph\" ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path ) FindShortestPathModuleConfig pydantic-model \u00b6 mode : str pydantic-field \u00b6 Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many'). GraphTypesEnum \u00b6 An enumeration.","title":"\u279c\u2007network_analysis"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modulesdefaultnetwork_analysis","text":"","title":"kiara_modules.default.network_analysis"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AddNodesToNetworkGraphModule","text":"Add nodes to an existing graph.","title":"AddNodesToNetworkGraphModule"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AddNodesToNetworkGraphModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"nodes\" : { \"type\" : \"table\" , \"doc\" : \"The table containing node attributes.\" , \"optional\" : True , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node index in the node attributes table.\" , \"optional\" : True , }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AddNodesToNetworkGraphModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }}","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AddNodesToNetworkGraphModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : nodes_table_value = inputs . get_value_obj ( \"node_attributes\" ) if nodes_table_value . is_none : # we return the graph as is # we are using the 'get_value_obj' method, because there is no need to retrieve the # actual data at all outputs . set_value ( \"graph\" , inputs . get_value_obj ( \"graph\" )) return input_graph : Graph = inputs . get_value_data ( \"graph\" ) graph : Graph = copy . deepcopy ( input_graph ) nodes_table_obj : pyarrow . Table = nodes_table_value . get_value_data () nodes_table_index = inputs . get_value_data ( \"index_column_name\" ) attr_dict = ( nodes_table_obj . to_pandas () . set_index ( nodes_table_index ) . to_dict ( \"index\" ) . items () ) graph . add_nodes_from ( attr_dict ) outputs . set_value ( \"graph\" , graph )","title":"process()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AugmentNetworkGraphModule","text":"Augment an existing graph with node attributes.","title":"AugmentNetworkGraphModule"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AugmentNetworkGraphModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"node_attributes\" : { \"type\" : \"table\" , \"doc\" : \"The table containing node attributes.\" , \"optional\" : True , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node index in the node attributes table.\" , \"optional\" : True , }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AugmentNetworkGraphModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }}","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.AugmentNetworkGraphModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : nodes_table_value = inputs . get_value_obj ( \"node_attributes\" ) if nodes_table_value . is_none or not nodes_table_value : # we return the graph as is # we are using the 'get_value_obj' method, because there is no need to retrieve the # actual data at all outputs . set_value ( \"graph\" , inputs . get_value_obj ( \"graph\" )) return input_graph : Graph = inputs . get_value_data ( \"graph\" ) graph : Graph = copy . deepcopy ( input_graph ) nodes_table_obj : pyarrow . Table = nodes_table_value . get_value_data () nodes_table_index = inputs . get_value_data ( \"index_column_name\" ) if nodes_table_index not in nodes_table_obj . column_names : raise KiaraProcessingException ( f \"Node attribute table does not have a column with (index) name ' { nodes_table_index } '. Available column names: { ', ' . join ( nodes_table_obj . column_names ) } \" ) attr_dict = ( nodes_table_obj . to_pandas () . set_index ( nodes_table_index ) . to_dict ( \"index\" ) . items () ) graph . add_nodes_from ( attr_dict ) outputs . set_value ( \"graph\" , graph )","title":"process()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphConfig","text":"","title":"CreateGraphConfig"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphConfig.graph_type","text":"The type of the graph. If not specified, a 'graph_type' input field will be added which will default to 'directed'.","title":"graph_type"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphFromEdgesTableModule","text":"Create a directed network graph object from tabular data.","title":"CreateGraphFromEdgesTableModule"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphFromEdgesTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"edges_table\" : { \"type\" : \"table\" , \"doc\" : \"The table to extract the edges from.\" , }, \"source_column\" : { \"type\" : \"string\" , \"default\" : \"source\" , \"doc\" : \"The name of the column that contains the edge source in edges table.\" , }, \"target_column\" : { \"type\" : \"string\" , \"default\" : \"target\" , \"doc\" : \"The name of the column that contains the edge target in the edges table.\" , }, \"weight_column\" : { \"type\" : \"string\" , \"default\" : \"weight\" , \"doc\" : \"The name of the column that contains the edge weight in edges table.\" , }, } if self . get_config_value ( \"graph_type\" ) is None : inputs [ \"graph_type\" ] = { \"type\" : \"string\" , \"default\" : \"directed\" , \"doc\" : \"The type of the graph. Allowed: 'undirected', 'directed', 'multi_directed', 'multi_undirected'.\" , } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphFromEdgesTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The (networkx) graph object.\" }, }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.CreateGraphFromEdgesTableModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : if self . get_config_value ( \"graph_type\" ) is not None : _graph_type = self . get_config_value ( \"graph_type\" ) else : _graph_type = inputs . get_value_data ( \"graph_type\" ) graph_type = GraphTypesEnum [ _graph_type ] edges_table_value = inputs . get_value_obj ( \"edges_table\" ) edges_table_obj : pyarrow . Table = edges_table_value . get_value_data () source_column = inputs . get_value_data ( \"source_column\" ) target_column = inputs . get_value_data ( \"target_column\" ) weight_column = inputs . get_value_data ( \"weight_column\" ) errors = [] if source_column not in edges_table_obj . column_names : errors . append ( source_column ) if target_column not in edges_table_obj . column_names : errors . append ( target_column ) if weight_column not in edges_table_obj . column_names : errors . append ( weight_column ) if errors : raise KiaraProcessingException ( f \"Can't create network graph, source table missing column(s): { ', ' . join ( errors ) } . Available columns: { ', ' . join ( edges_table_obj . column_names ) } .\" ) min_table = edges_table_obj . select ( ( source_column , target_column , weight_column ) ) pandas_table = min_table . to_pandas () if graph_type != GraphTypesEnum . directed : raise NotImplementedError ( \"Only 'directed' graphs supported at the moment.\" ) graph_cls = nx . DiGraph graph : nx . DiGraph = nx . from_pandas_edgelist ( pandas_table , source_column , target_column , edge_attr = True , create_using = graph_cls , ) outputs . set_value ( \"graph\" , graph )","title":"process()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModule","text":"Extract inherent properties of a network graph.","title":"ExtractGraphPropertiesModule"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: result = {} if self . get_config_value ( \"find_largest_component\" ): result [ \"largest_component\" ] = { \"type\" : \"network_graph\" , \"doc\" : \"A sub-graph of the largest component of the graph.\" , } result [ \"density_largest_component\" ] = { \"type\" : \"float\" , \"doc\" : \"The density of the largest component.\" , } if self . get_config_value ( \"number_of_nodes\" ): result [ \"number_of_nodes\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of nodes in the graph.\" , } if self . get_config_value ( \"number_of_edges\" ): result [ \"number_of_edges\" ] = { \"type\" : \"integer\" , \"doc\" : \"The number of edges in the graph.\" , } if self . get_config_value ( \"density\" ): result [ \"density\" ] = { \"type\" : \"float\" , \"doc\" : \"The density of the graph.\" } return result","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : graph : Graph = inputs . get_value_data ( \"graph\" ) if self . get_config_value ( \"find_largest_component\" ): lc_graph = copy . deepcopy ( graph ) # largest_component = max(nx.strongly_connected_components_recursive(lc_graph), key=len) lc_graph . remove_nodes_from ( list ( nx . isolates ( lc_graph )) ) # remove unconnected nodes from graph lc_density = nx . density ( lc_graph ) outputs . set_values ( largest_component = lc_graph , density_largest_component = lc_density ) if self . get_config_value ( \"number_of_nodes\" ): outputs . set_values ( number_of_nodes = len ( graph . nodes )) if self . get_config_value ( \"number_of_edges\" ): outputs . set_values ( number_of_edges = len ( graph . edges )) if self . get_config_value ( \"density\" ): density = nx . density ( graph ) outputs . set_values ( density = density )","title":"process()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModuleConfig","text":"","title":"ExtractGraphPropertiesModuleConfig"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModuleConfig.density","text":"Calculate the graph density.","title":"density"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModuleConfig.find_largest_component","text":"Find the largest component of a graph.","title":"find_largest_component"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModuleConfig.number_of_edges","text":"Count the number of edges","title":"number_of_edges"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.ExtractGraphPropertiesModuleConfig.number_of_nodes","text":"Count the number of nodes.","title":"number_of_nodes"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModule","text":"Find the shortest path between two nodes in a graph.","title":"FindShortestPathModule"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/network_analysis.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"source_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the source node.\" }, \"target_node\" : { \"type\" : \"any\" , \"doc\" : \"The id of the target node.\" }, } else : return { \"graph\" : { \"type\" : \"network_graph\" , \"doc\" : \"The network graph\" }, \"source_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the source nodes.\" }, \"target_nodes\" : { \"type\" : \"list\" , \"doc\" : \"The ids of the target nodes.\" }, }","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/network_analysis.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: mode = self . get_config_value ( \"mode\" ) if mode == \"single-pair\" : return { \"path\" : { \"type\" : \"array\" , \"doc\" : \"The shortest path between two nodes.\" } } else : return { \"paths\" : { \"type\" : \"table\" , \"doc\" : \"A table with 'source', 'target' and 'path' column.\" , } }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/network_analysis.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : mode = self . get_config_value ( \"mode\" ) if mode != \"single-pair\" : raise NotImplementedError () graph : Graph = inputs . get_value_data ( \"graph\" ) source : typing . Any = inputs . get_value_data ( \"source_node\" ) target : typing . Any = inputs . get_value_data ( \"target_node\" ) if source not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, source ' { source } ' not in graph.\" ) if target not in graph . nodes : raise KiaraProcessingException ( f \"Can't process shortest path, target ' { target } ' not in graph.\" ) shortest_path = nx . shortest_path ( graph , source = source , target = target ) outputs . set_value ( \"path\" , shortest_path )","title":"process()"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModuleConfig","text":"","title":"FindShortestPathModuleConfig"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.FindShortestPathModuleConfig.mode","text":"Whether to calculate one shortest path for only one pair ('single-pair'), or use two node lists as input and select one of the following strategies: shortest path for each pair ('one-to-one'), the shortest path to all targets ('one-to-many'), or a matrix of all possible combinations ('many-to-many').","title":"mode"},{"location":"api_reference/kiara_modules.default.network_analysis/#kiara_modules.default.network_analysis.GraphTypesEnum","text":"An enumeration.","title":"GraphTypesEnum"},{"location":"api_reference/kiara_modules.default.scratchpad/","text":"kiara_modules.default.scratchpad \u00b6 PrepareNodesTableLenaModule \u00b6 Prepare tabular data so it can be used as a 'nodes_table' input in the a directed graph module. This is a very specific module, only accepting a very specific data format and as such only suitable as a proof-of-concept. Later on, this will be replaced by a more generic module (or pipeline). create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/scratchpad.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The 'raw' table incl. edges.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/scratchpad.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A normalized table where every row represents the metadata for a single network node.\" , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node identifier.\" , }, } process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/scratchpad.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : t : pyarrow . Table = inputs . get_value_data ( \"table\" ) df = t . to_pandas () df1 = df . iloc [:, 0 : 11 ] df1 . columns = [ \"Id\" , \"LabelOrig\" , \"LabelTrans\" , \"Year\" , \"Type\" , \"Language\" , \"City\" , \"CountryOld\" , \"CountryNew\" , \"Latitude\" , \"Longitude\" , ] df2 = df . iloc [ :, 11 : ] # This slices the dataframe in half creating a df of just the TargetJournals data df2 . columns = [ \"Id\" , \"Year\" , \"LabelOrig\" , \"LabelTrans\" , \"Type\" , \"Language\" , \"City\" , \"CountryOld\" , \"CountryNew\" , \"Latitude\" , \"Longitude\" , ] extr_nodes = df1 . append ( df2 ) extr_nodes_unique = extr_nodes . drop_duplicates ( subset = [ \"Id\" ]) result = pyarrow . Table . from_pandas ( extr_nodes_unique ) outputs . set_values ( table = result , index_column_name = \"Id\" )","title":"\u279c\u2007scratchpad"},{"location":"api_reference/kiara_modules.default.scratchpad/#kiara_modulesdefaultscratchpad","text":"","title":"kiara_modules.default.scratchpad"},{"location":"api_reference/kiara_modules.default.scratchpad/#kiara_modules.default.scratchpad.PrepareNodesTableLenaModule","text":"Prepare tabular data so it can be used as a 'nodes_table' input in the a directed graph module. This is a very specific module, only accepting a very specific data format and as such only suitable as a proof-of-concept. Later on, this will be replaced by a more generic module (or pipeline).","title":"PrepareNodesTableLenaModule"},{"location":"api_reference/kiara_modules.default.scratchpad/#kiara_modules.default.scratchpad.PrepareNodesTableLenaModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/scratchpad.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The 'raw' table incl. edges.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.scratchpad/#kiara_modules.default.scratchpad.PrepareNodesTableLenaModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/scratchpad.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"A normalized table where every row represents the metadata for a single network node.\" , }, \"index_column_name\" : { \"type\" : \"string\" , \"doc\" : \"The name of the column that contains the node identifier.\" , }, }","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.scratchpad/#kiara_modules.default.scratchpad.PrepareNodesTableLenaModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/scratchpad.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : t : pyarrow . Table = inputs . get_value_data ( \"table\" ) df = t . to_pandas () df1 = df . iloc [:, 0 : 11 ] df1 . columns = [ \"Id\" , \"LabelOrig\" , \"LabelTrans\" , \"Year\" , \"Type\" , \"Language\" , \"City\" , \"CountryOld\" , \"CountryNew\" , \"Latitude\" , \"Longitude\" , ] df2 = df . iloc [ :, 11 : ] # This slices the dataframe in half creating a df of just the TargetJournals data df2 . columns = [ \"Id\" , \"Year\" , \"LabelOrig\" , \"LabelTrans\" , \"Type\" , \"Language\" , \"City\" , \"CountryOld\" , \"CountryNew\" , \"Latitude\" , \"Longitude\" , ] extr_nodes = df1 . append ( df2 ) extr_nodes_unique = extr_nodes . drop_duplicates ( subset = [ \"Id\" ]) result = pyarrow . Table . from_pandas ( extr_nodes_unique ) outputs . set_values ( table = result , index_column_name = \"Id\" )","title":"process()"},{"location":"api_reference/kiara_modules.default.strings/","text":"kiara_modules.default.strings \u00b6 PrettyPrintModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"item\" : { \"type\" : \"any\" , \"doc\" : \"The object to convert into a pretty string.\" , }, \"max_lines\" : { \"type\" : \"integer\" , \"doc\" : \"Maximum number of lines the output should have.\" , \"optional\" : True , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"pretty_string\" : { \"type\" : \"string\" , \"doc\" : \"Pretty string output for the input object.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : value_type = inputs . get_value_obj ( \"item\" ) . type_name input_value : Value = inputs . get_value_data ( \"item\" ) max_lines = inputs . get_value_data ( \"max_lines\" ) if value_type == \"table\" : half_lines : typing . Optional [ int ] = None if max_lines : half_lines = int ( max_lines / 2 ) input_value_str = pretty_print_arrow_table ( input_value , num_head = half_lines , num_tail = half_lines ) else : input_value_str = pformat ( input_value ) outputs . set_value ( \"pretty_string\" , input_value_str ) RegexModule \u00b6 Check whether the input string matches a provided regular expression. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result ) RegexModuleConfig pydantic-model \u00b6 only_first_match : bool pydantic-field \u00b6 Whether to only return the first match, or all matches. regex : str pydantic-field required \u00b6 The regex to apply. ReplaceModuleConfig pydantic-model \u00b6 default_value : str pydantic-field \u00b6 The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself. replacement_map : Dict [ str , str ] pydantic-field required \u00b6 A map, containing the strings to be replaced as keys, and the replacements as values. ReplaceStringModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }} process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result ) StringManipulationModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }} create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }} process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result )","title":"\u279c\u2007strings"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modulesdefaultstrings","text":"","title":"kiara_modules.default.strings"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.PrettyPrintModule","text":"","title":"PrettyPrintModule"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.PrettyPrintModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs : typing . Dict [ str , typing . Dict [ str , typing . Any ]] = { \"item\" : { \"type\" : \"any\" , \"doc\" : \"The object to convert into a pretty string.\" , }, \"max_lines\" : { \"type\" : \"integer\" , \"doc\" : \"Maximum number of lines the output should have.\" , \"optional\" : True , }, } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.PrettyPrintModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"pretty_string\" : { \"type\" : \"string\" , \"doc\" : \"Pretty string output for the input object.\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.PrettyPrintModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : value_type = inputs . get_value_obj ( \"item\" ) . type_name input_value : Value = inputs . get_value_data ( \"item\" ) max_lines = inputs . get_value_data ( \"max_lines\" ) if value_type == \"table\" : half_lines : typing . Optional [ int ] = None if max_lines : half_lines = int ( max_lines / 2 ) input_value_str = pretty_print_arrow_table ( input_value , num_head = half_lines , num_tail = half_lines ) else : input_value_str = pformat ( input_value ) outputs . set_value ( \"pretty_string\" , input_value_str )","title":"process()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModule","text":"Check whether the input string matches a provided regular expression.","title":"RegexModule"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The text to match.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: if self . get_config_value ( \"only_first_match\" ): output_schema = { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The first match.\" }} else : raise NotImplementedError () return output_schema","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) regex = self . get_config_value ( \"regex\" ) matches = re . findall ( regex , text ) if not matches : raise KiaraProcessingException ( f \"No match for regex: { regex } \" ) if self . get_config_value ( \"only_first_match\" ): result = matches [ 0 ] else : result = matches outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModuleConfig","text":"","title":"RegexModuleConfig"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModuleConfig.only_first_match","text":"Whether to only return the first match, or all matches.","title":"only_first_match"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.RegexModuleConfig.regex","text":"The regex to apply.","title":"regex"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceModuleConfig","text":"","title":"ReplaceModuleConfig"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceModuleConfig.default_value","text":"The default value to use if the string to be replaced is not in the replacement map. By default, this just returns the string itself.","title":"default_value"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceModuleConfig.replacement_map","text":"A map, containing the strings to be replaced as keys, and the replacements as values.","title":"replacement_map"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceStringModule","text":"","title":"ReplaceStringModule"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceStringModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceStringModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The replaced string.\" }}","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.ReplaceStringModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : text = inputs . get_value_data ( \"text\" ) repl_map = self . get_config_value ( \"replacement_map\" ) default = self . get_config_value ( \"default_value\" ) if text not in repl_map . keys (): if default is None : result = text else : result = default else : result = repl_map [ text ] outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.StringManipulationModule","text":"","title":"StringManipulationModule"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.StringManipulationModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/strings.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The input string.\" }}","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.StringManipulationModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/strings.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"text\" : { \"type\" : \"string\" , \"doc\" : \"The processed string.\" }}","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.strings/#kiara_modules.default.strings.StringManipulationModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/strings.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_string = inputs . get_value_data ( \"text\" ) result = self . process_string ( input_string ) outputs . set_value ( \"text\" , result )","title":"process()"},{"location":"api_reference/kiara_modules.default.tabular_data/","text":"kiara_modules.default.tabular_data \u00b6 CreateTableFromFileModule \u00b6 Import table-like data from an item in the data registry. create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"file\" : { \"type\" : \"file\" , \"doc\" : \"The file that contains tabular data.\" , \"optional\" : False , } } if self . get_config_value ( \"allow_column_filter\" ): inputs [ \"columns\" ] = { \"type\" : \"array\" , \"doc\" : \"If provided, only import the columns that match items in this list.\" , \"optional\" : False , } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"the imported table\" }} process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_file : FileModel = inputs . get_value_data ( \"file\" ) imported_data = pa . csv . read_csv ( input_file . path ) if self . get_config_value ( \"allow_column_filter\" ): if self . get_config_value ( \"columns\" ): imported_data = imported_data . select ( self . get_config_value ( \"only_columns\" ) ) outputs . set_value ( \"table\" , imported_data ) CreateTableFromTextFilesConfig pydantic-model \u00b6 columns : List [ str ] pydantic-field \u00b6 A list of columns to add to the table. Available properties: id, rel_path, orig_filename, orig_path, import_time, mime_type, size, content, path, file_name CreateTableFromTextFilesModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"files\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The files to use for the table.\" } } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: id_column = \"id\" path_column = \"rel_path\" content = \"content\" outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : f \"A table with the index column ' { id_column } ', a column ' { path_column } ' that indicates the relative path of the file in the bundle, and a column ' { content } ' that holds the (text) content of every file.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : bundle : FileBundleModel = inputs . get_value_data ( \"files\" ) columns = self . get_config_value ( \"columns\" ) if not columns : columns = DEFAULT_COLUMNS if \"content\" in columns : file_dict = bundle . read_text_file_contents () else : file_dict = {} for rel_path in bundle . included_files . keys (): file_dict [ rel_path ] = None # type: ignore tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : value = index elif column == \"rel_path\" : value = rel_path else : file_model = bundle . included_files [ rel_path ] value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( value ) table = pa . Table . from_pydict ( tabular ) outputs . set_value ( \"table\" , table ) CreateTableModuleConfig pydantic-model \u00b6 allow_column_filter : bool pydantic-field \u00b6 Whether to add an input option to filter columns. FilterTableModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered ) MergeTableModule \u00b6 create_input_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"sources\" : { \"type\" : \"dict\" , \"doc\" : \"The source tables and/or columns.\" } } return inputs create_output_schema ( self ) \u00b6 Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs process ( self , inputs , outputs ) \u00b6 Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : sources = inputs . get_value_data ( \"sources\" ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , pa . Array ): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table )","title":"\u279c\u2007tabular_data"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modulesdefaulttabular_data","text":"","title":"kiara_modules.default.tabular_data"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromFileModule","text":"Import table-like data from an item in the data registry.","title":"CreateTableFromFileModule"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromFileModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"file\" : { \"type\" : \"file\" , \"doc\" : \"The file that contains tabular data.\" , \"optional\" : False , } } if self . get_config_value ( \"allow_column_filter\" ): inputs [ \"columns\" ] = { \"type\" : \"array\" , \"doc\" : \"If provided, only import the columns that match items in this list.\" , \"optional\" : False , } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromFileModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: return { \"table\" : { \"type\" : \"table\" , \"doc\" : \"the imported table\" }}","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromFileModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_file : FileModel = inputs . get_value_data ( \"file\" ) imported_data = pa . csv . read_csv ( input_file . path ) if self . get_config_value ( \"allow_column_filter\" ): if self . get_config_value ( \"columns\" ): imported_data = imported_data . select ( self . get_config_value ( \"only_columns\" ) ) outputs . set_value ( \"table\" , imported_data )","title":"process()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesConfig","text":"","title":"CreateTableFromTextFilesConfig"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesConfig.columns","text":"A list of columns to add to the table. Available properties: id, rel_path, orig_filename, orig_path, import_time, mime_type, size, content, path, file_name","title":"columns"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesModule","text":"","title":"CreateTableFromTextFilesModule"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"files\" : { \"type\" : \"file_bundle\" , \"doc\" : \"The files to use for the table.\" } } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: id_column = \"id\" path_column = \"rel_path\" content = \"content\" outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : f \"A table with the index column ' { id_column } ', a column ' { path_column } ' that indicates the relative path of the file in the bundle, and a column ' { content } ' that holds the (text) content of every file.\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableFromTextFilesModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : bundle : FileBundleModel = inputs . get_value_data ( \"files\" ) columns = self . get_config_value ( \"columns\" ) if not columns : columns = DEFAULT_COLUMNS if \"content\" in columns : file_dict = bundle . read_text_file_contents () else : file_dict = {} for rel_path in bundle . included_files . keys (): file_dict [ rel_path ] = None # type: ignore tabular : typing . Dict [ str , typing . List [ typing . Any ]] = {} for column in columns : for index , rel_path in enumerate ( sorted ( file_dict . keys ())): if column == \"content\" : value : typing . Any = file_dict [ rel_path ] elif column == \"id\" : value = index elif column == \"rel_path\" : value = rel_path else : file_model = bundle . included_files [ rel_path ] value = getattr ( file_model , column ) tabular . setdefault ( column , []) . append ( value ) table = pa . Table . from_pydict ( tabular ) outputs . set_value ( \"table\" , table )","title":"process()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableModuleConfig","text":"","title":"CreateTableModuleConfig"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.CreateTableModuleConfig.allow_column_filter","text":"Whether to add an input option to filter columns.","title":"allow_column_filter"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.FilterTableModule","text":"","title":"FilterTableModule"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.FilterTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The table to filter.\" }, \"mask\" : { \"type\" : \"array\" , \"doc\" : \"An mask array of booleans of the same length as the table.\" , }, } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.FilterTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The filtered table.\" }} return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.FilterTableModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : input_table : pa . Table = inputs . get_value_data ( \"table\" ) filter_array : pa . Array = inputs . get_value_data ( \"mask\" ) filtered = input_table . filter ( filter_array ) outputs . set_value ( \"table\" , filtered )","title":"process()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.MergeTableModule","text":"","title":"MergeTableModule"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.MergeTableModule.create_input_schema","text":"Abstract method to implement by child classes, returns a description of the input schema of this module. Source code in default/tabular_data.py def create_input_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: inputs = { \"sources\" : { \"type\" : \"dict\" , \"doc\" : \"The source tables and/or columns.\" } } return inputs","title":"create_input_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.MergeTableModule.create_output_schema","text":"Abstract method to implement by child classes, returns a description of the output schema of this module. Source code in default/tabular_data.py def create_output_schema ( self , ) -> typing . Mapping [ str , typing . Union [ ValueSchema , typing . Mapping [ str , typing . Any ]] ]: outputs = { \"table\" : { \"type\" : \"table\" , \"doc\" : \"The merged table, including all source tables and columns.\" , } } return outputs","title":"create_output_schema()"},{"location":"api_reference/kiara_modules.default.tabular_data/#kiara_modules.default.tabular_data.MergeTableModule.process","text":"Abstract method to implement by child classes, should be a pure, idempotent function that uses the values from inputs , and stores results in the provided outputs object. Parameters: Name Type Description Default inputs ValueSet the input value set required outputs ValueSet the output value set required Source code in default/tabular_data.py def process ( self , inputs : ValueSet , outputs : ValueSet ) -> None : sources = inputs . get_value_data ( \"sources\" ) len_dict = {} arrays = [] column_names = [] for source_key , table_or_column in sources . items (): if isinstance ( table_or_column , pa . Table ): rows = table_or_column . num_rows for name in table_or_column . schema . names : column = table_or_column . column ( name ) arrays . append ( column ) column_names . append ( name ) elif isinstance ( table_or_column , pa . Array ): rows = len ( table_or_column ) arrays . append ( table_or_column ) column_names . append ( source_key ) else : raise KiaraProcessingException ( f \"Can't merge table: invalid type ' { type ( table_or_column ) } ' for source ' { source_key } '.\" ) len_dict [ source_key ] = rows all_rows = None for source_key , rows in len_dict . items (): if all_rows is None : all_rows = rows else : if all_rows != rows : all_rows = None break if all_rows is None : len_str = \"\" for name , rows in len_dict . items (): len_str = f \" { name } ( { rows } )\" raise KiaraProcessingException ( f \"Can't merge table, sources have different lengths: { len_str } \" ) table = pa . Table . from_arrays ( arrays = arrays , names = column_names ) outputs . set_value ( \"table\" , table )","title":"process()"}]}